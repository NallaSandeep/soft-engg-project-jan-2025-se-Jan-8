{
    "course": {
      "course_id": 3,
      "code": "SE101",
      "title": "Software Engineering",
      "description": "**A comprehensive course covering software engineering principles, processes, and best practices across the entire software development lifecycle, from requirements gathering to post-deployment maintenance. Emphasis is placed on practical applications, risk management, and modern software methodologies.** [1] The course contrasts traditional plan-driven models (Waterfall, V-Model) with adaptive frameworks (Agile, Scrum), examining their strengths, limitations, and use cases [2, 3]. Students will learn about documenting requirements using Software Requirements Specifications (SRS), creating design artifacts (UML diagrams, architectural blueprints), and implementing robust testing strategies [3]. Project estimation, risk management, and the importance of iterative feedback in agile development are also covered [3].",
      "instructor_id": 1003,
      "credits": 4,
      "department": "Computer Science",
      "image_url": "/assets/courses/se101/cover.jpg",
      "prerequisites": [
        "Basic programming knowledge"
      ],
      "learning_outcomes": [
        "**Understand the Software Development Lifecycle (SDLC) and its phases** [4]",
        "**Differentiate between plan-driven and Agile methodologies** [4]",
        "**Analyze and document software requirements using SRS** [4]",
        "**Apply software design principles and architectural patterns** [4]",
        "**Develop effective project estimation and scheduling techniques** [4]",
        "**Implement software testing strategies at various levels** [4]",
        "**Manage risk, change, and version control in software projects** [4]",
        "**Ensure software quality and maintainability through best practices** [2]",
        "Understand different software architectural styles and their trade-offs.",
        "Apply various software design patterns to solve common design problems.",
        "Master different levels and types of software testing.",
        "Understand the principles and practices of software deployment and DevOps.",
        "Learn about software maintenance and evolution processes.",
        "Explore advanced concepts in Agile project management."
      ],
      "assessment_methods": [
        "Quizzes",
        "Assignments",
        "Project Work",
        "Final Exam"
      ],
      "delivery_mode": "Online",
      "tools_and_technologies": [
        "UML",
        "JIRA",
        "Git",
        "Testing Frameworks"
      ],
      "LLM_Summary": {
        "summary": "**This course provides a comprehensive exploration of the Software Development Lifecycle (SDLC), covering the key phases: requirement gathering, system design, development, testing, deployment, and maintenance.** [2] It contrasts traditional plan-driven models (Waterfall, V-Model) with adaptive frameworks (Agile, Scrum), examining their strengths, limitations, and use cases [2, 3]. The course emphasizes practical applications such as documenting requirements using Software Requirements Specifications (SRS), creating design artifacts (UML diagrams, architectural blueprints), and implementing robust testing strategies (unit, integration, system, and user acceptance testing) [3]. Students learn about project estimation techniques, risk management strategies, and the importance of iterative feedback in modern agile development [3]. Special focus is given to balancing documentation with flexibility, collaborating with stakeholders, and ensuring software quality through continuous testing and maintenance [2]. By the end of the course, students will be equipped to design, manage, and deliver complex software systems while applying industry best practices [2].",
        "concepts_covered": [
          "**Software development lifecycle phases (SDLC)** [3]",
          "**Plan-driven vs. Agile methodologies** [3]",
          "**Requirement gathering and specification (SRS creation)** [3]",
          "**Software design principles and architectural patterns** [3]",
          "User interface and experience design best practices [3]",
          "**Project estimation (Function Point, COCOMO models)** [3]",
          "Scheduling techniques (Gantt charts, critical path method) [3]",
          "Risk identification, assessment, and mitigation strategies [3]",
          "**Software testing methodologies (unit, integration, system, UAT)** [5]",
          "Maintenance categories: corrective, adaptive, perfective, preventive [5]",
          "Change management and version control fundamentals [5]",
          "Software quality assurance (SQA) and code reviews [5]",
          "Ethical considerations and professional responsibility in software development [5]",
          "Software architecture styles (e.g., monolithic, microservices, layered)",
          "Software design patterns (e.g., creational, structural, behavioral)",
          "Test-driven development (TDD)",
          "Continuous Integration/Continuous Deployment (CI/CD)",
          "DevOps principles and practices",
          "Software refactoring",
          "Advanced Agile frameworks (e.g., SAFe, LeSS)",
          "Software metrics and measurement"
        ],
        "concepts_not_covered": [
          "Advanced programming techniques (e.g., multithreading, concurrency) [5]",
          "Specific implementation of DevOps and CI/CD pipelines [5]",
          "Cloud-native software development and microservices [5]",
          "Machine learning integration and AI-driven software engineering [6]",
          "Enterprise-level security frameworks (e.g., OWASP, ISO 27001) [6]",
          "Formal methods in software engineering",
          "Real-time and embedded software development",
          "Software project recovery techniques"
        ]
      },
      "acronyms": {
        "SDLC": "Software Development Lifecycle",
        "SRS": "Software Requirements Specification",
        "UML": "Unified Modeling Language",
        "TDD": "Test-Driven Development",
        "BDD": "Behavior-Driven Development",
        "CI/CD": "Continuous Integration / Continuous Deployment",
        "IaC": "Infrastructure as Code",
        "SAFe": "Scaled Agile Framework",
        "LeSS": "Large-Scale Scrum",
        "SQA": "Software Quality Assurance",
        "AI": "Artificial Intelligence",
        "ML": "Machine Learning",
        "IoT": "Internet of Things",
        "CMMI": "Capability Maturity Model Integration",
        "IEEE": "Institute of Electrical and Electronics Engineers",
        "ACM": "Association for Computing Machinery",
        "OWASP": "Open Web Application Security Project",
        "ISO": "International Organization for Standardization"
      }
      ,
      "synonyms": {
        "Software Development Lifecycle": ["Software Development Process"],
        "Plan-Driven Models": ["Traditional Lifecycle Models", "Heavyweight Processes"],
        "Agile Methodologies": ["Iterative and Incremental Frameworks", "Adaptive Processes"],
        "Requirement Gathering": ["Requirements Elicitation", "Requirements Engineering"],
        "Software Maintenance": ["System Evolution", "Post-Deployment Support"],
        "DevOps": ["Development-Operations Integration", "Continuous Delivery Pipeline"],
        "Refactoring": ["Code Restructuring", "Continuous Code Improvement"],
        "Technical Debt": ["Design Debt", "Code Debt"],
        "Software Architecture": ["System Structure", "Architectural Styles"],
        "Software Testing": ["Verification and Validation", "Quality Assurance"],
        "Non-Functional Requirements": ["Quality Attributes", "System Constraints"],
        "Software Design Principles": ["SOLID Principles", "Architectural Guidelines"],
        "Software Design Patterns": ["Reusable Solutions", "Common Design Approaches"],
        "Deployment Strategies": ["Release Approaches", "Production Rollout Methods"],
        "Agile Project Management": ["Adaptive Planning", "Scrum-Based Management"],
        "Scaling Agile": ["SAFe Implementation", "LeSS Framework Adoption"],
        "Software Engineering Ethics": ["Professional Responsibility", "IEEE/ACM Code of Conduct"],
        "Future Trends in Software Engineering": ["Emerging Technologies", "Industry Directions"]
      }
      
    },
    "weeks": [
      {
        "week_id": 1,
        "course_id": 3,
        "order": 1,
        "title": "**Week 1: Deconstructing the Software Development Process**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week provides a comprehensive foundation in software engineering principles and methodologies.** [6] We begin by tracing the historical evolution of software development from ad-hoc coding to disciplined engineering practices [7]. The curriculum covers both traditional (Waterfall) and modern (Agile) development methodologies in depth, examining their phases, documentation requirements, and suitability for different project types [7]. Through case studies of large-scale systems like Amazon's platform, we explore component-based architecture, module integration patterns, and the critical role of development tools across the entire lifecycle [7]. The week emphasizes practical application through hands-on exercises in process selection, requirements documentation, and system decomposition [7]. Special attention is given to quality assurance practices, including test-driven development and continuous integration within different process models [7]. The material prepares students to evaluate tradeoffs between predictability and flexibility when selecting development approaches for real-world projects [7].",
          "concepts_covered": [
            "**Historical evolution of software engineering practices** [7]",
            "**Waterfall model phases and documentation requirements** [7]",
            "**Agile principles and iterative development cycles** [7]",
            "Component-based system architecture [7]",
            "Module integration patterns and interface design [7]",
            "Development tools for requirements, coding, and testing [7]",
            "Test-driven development methodologies [7]",
            "Quality assurance in different process models [7]",
            "System decomposition techniques [8]",
            "Case study analysis of large-scale platforms [8]",
            "Introduction to different SDLC models (V-Model, Incremental)",
            "The importance of process tailoring"
          ],
          "concepts_not_covered": [
            "Advanced DevOps toolchains and CI/CD pipelines [8]",
            "Microservices architecture patterns [8]",
            "Domain-driven design principles [8]",
            "Formal specification languages (Z, VDM) [8]",
            "Quantitative process improvement metrics (CMMI) [8]"
          ]
        }
      },
      {
        "week_id": 2,
        "course_id": 3,
        "order": 2,
        "title": "**Week 2: Software Requirements Engineering**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week delves deeply into requirements engineering, covering both theoretical foundations and practical techniques.** [8] Students learn comprehensive methods for stakeholder identification and engagement, including advanced interview techniques, ethnographic observation, and requirements workshops [9]. The curriculum contrasts functional requirements (system behaviors) with quality attributes (non-functional requirements), providing frameworks for specifying, prioritizing, and validating each type [9]. Through hands-on exercises, students practice transforming vague stakeholder needs into precise, testable specifications using templates based on IEEE standards [9]. Special attention is given to managing requirements volatility, tracing requirements through development, and handling conflicting stakeholder priorities [9]. Real-world case studies demonstrate the consequences of poor requirements practices, while best practices for requirements change management in agile contexts are explored in depth [9]. The week culminates in a comprehensive requirements specification project where students apply all learned techniques to a complex system scenario [9].",
          "concepts_covered": [
            "**Stakeholder analysis and engagement strategies** [9]",
            "**Advanced elicitation techniques (interviews, observation, workshops)** [9]",
            "**Functional vs. non-functional requirements specification** [9]",
            "**Requirements prioritization methods (MoSCoW, Kano)** [9]",
            "**Software Requirements Specification (SRS) documentation** [10]",
            "Requirements traceability matrices [10]",
            "Validation and verification techniques [10]",
            "Handling requirements conflicts and tradeoffs [10]",
            "Quality attributes specification (reliability, scalability, etc.) [10]",
            "Agile requirements management (user stories, backlog grooming) [10]",
            "Use case modeling and diagramming",
            "Requirements management tools"
          ],
          "concepts_not_covered": [
            "Natural language processing for requirements extraction [10]",
            "Goal-oriented requirements engineering (KAOS) [10]",
            "Formal requirements modeling (UML, SysML) [10]",
            "Requirements mining from legacy systems [10]",
            "AI-assisted requirements prioritization [10]"
          ]
        }
      },
      {
        "week_id": 3,
        "course_id": 3,
        "order": 3,
        "title": "**Week 3: Software Architecture and Design**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week provides a rigorous exploration of software architecture styles and design principles.** We begin by examining different architectural patterns such as monolithic, layered, microservices, and event-driven architectures, analyzing their trade-offs in terms of scalability, maintainability, and fault tolerance. The curriculum covers key design principles like modularity, cohesion, coupling, abstraction, and the SOLID principles of object-oriented design. Through case studies and practical exercises, students learn to apply architectural blueprints and design patterns (creational, structural, and behavioral) to solve common software design challenges. Emphasis is placed on creating robust, flexible, and maintainable software systems. Advanced topics include designing for non-functional requirements like performance and security at the architectural level, and the role of UML in documenting software design.",
          "concepts_covered": [
            "**Overview of software architecture and its importance**",
            "**Architectural styles: Monolithic, Layered, Client-Server, Microservices, Event-Driven**",
            "**Architectural patterns and their characteristics**",
            "**Design principles: Modularity, Cohesion, Coupling, Abstraction**",
            "**SOLID principles of Object-Oriented Design (SRP, OCP, LSP, ISP, DIP)**",
            "**Creational Design Patterns (Singleton, Factory, Builder, Prototype, Abstract Factory)**",
            "**Structural Design Patterns (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy)**",
            "**Behavioral Design Patterns (Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor)**",
            "Designing for non-functional requirements (performance, security, scalability)",
            "Using UML for architectural and design documentation (Class Diagrams, Component Diagrams, Deployment Diagrams)"
          ],
          "concepts_not_covered": [
            "Domain-Specific Architectures",
            "Formal Architecture Description Languages",
            "Advanced topics in distributed systems architecture",
            "Hardware-software co-design"
          ]
        }
      },
      {
        "week_id": 4,
        "course_id": 3,
        "order": 4,
        "title": "**Week 4: Software Testing and Quality Assurance**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week provides comprehensive coverage of software testing methodologies and quality assurance practices.** Students learn about different levels of testing (unit, integration, system, acceptance) and various testing techniques (black-box, white-box, gray-box). The curriculum covers test planning, test case design, test execution, and defect management. Emphasis is placed on automation in testing using tools and frameworks. Students will also learn about software quality attributes (reliability, usability, performance, security, maintainability) and how to ensure these through quality assurance processes, including code reviews, static analysis, and dynamic analysis. Advanced topics include test-driven development (TDD), behavior-driven development (BDD), and performance testing.",
          "concepts_covered": [
            "**Fundamentals of software testing: Goals, principles, and terminology**",
            "**Levels of testing: Unit, Integration, System, Acceptance Testing**",
            "**Testing techniques: Black-box testing (Equivalence Partitioning, Boundary Value Analysis, Decision Table Testing, State Transition Testing, Use Case Testing), White-box testing (Statement Coverage, Branch Coverage, Path Coverage)**",
            "**Test planning: Test strategy, test plan documents, test environment setup**",
            "**Test case design: Writing effective test cases, test data management**",
            "**Test execution: Test execution tools, defect tracking, test reporting**",
            "**Test automation: Introduction to test automation frameworks (e.g., Selenium, JUnit), selecting test cases for automation**",
            "**Software Quality Attributes: Reliability, Usability, Performance, Security, Maintainability, Portability**",
            "**Software Quality Assurance (SQA): Processes, standards, and metrics**",
            "Code reviews and static analysis",
            "Dynamic analysis and profiling",
            "Test-Driven Development (TDD) and Behavior-Driven Development (BDD)"
          ],
          "concepts_not_covered": [
            "Formal verification and validation",
            "Mutation testing",
            "AI in software testing",
            "Security testing in depth (penetration testing, vulnerability scanning)"
          ]
        }
      },
      {
        "week_id": 5,
        "course_id": 3,
        "order": 5,
        "title": "**Week 5: Software Deployment and DevOps**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week explores the principles and practices of software deployment and DevOps.** Students will learn about different deployment strategies (e.g., blue-green, canary releases, rolling updates), infrastructure as code (IaC), and continuous integration/continuous deployment (CI/CD) pipelines. The curriculum covers the use of containerization technologies like Docker and orchestration tools like Kubernetes. Emphasis is placed on automation, monitoring, and logging in modern deployment processes. Students will also learn about the cultural aspects of DevOps, including collaboration and communication between development and operations teams.",
          "concepts_covered": [
            "**Introduction to Software Deployment: Strategies and challenges**",
            "**Deployment Strategies: Blue-Green Deployment, Canary Releases, Rolling Updates**",
            "**Infrastructure as Code (IaC): Principles and tools (e.g., Terraform, Ansible)**",
            "**Continuous Integration (CI): Concepts, benefits, and tools (e.g., Jenkins, GitLab CI)**",
            "**Continuous Deployment (CD): Concepts, benefits, and implementation**",
            "**CI/CD Pipelines: Designing and implementing automated build, test, and deployment workflows**",
            "**Containerization with Docker: Concepts, image creation, and management**",
            "**Orchestration with Kubernetes: Pods, deployments, services, and scaling**",
            "**Monitoring and Logging: Tools and techniques for application and infrastructure monitoring (e.g., Prometheus, Grafana, ELK Stack)**",
            "**DevOps Culture: Collaboration, communication, and automation**",
            "Configuration Management"
          ],
          "concepts_not_covered": [
            "Advanced Kubernetes networking",
            "Serverless deployment models in detail",
            "Security in DevOps (DevSecOps) in depth",
            "Cost optimization in cloud deployments"
          ]
        }
      },
      {
        "week_id": 6,
        "course_id": 3,
        "order": 6,
        "title": "**Week 6: Software Maintenance and Evolution**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week focuses on the processes and challenges of software maintenance and evolution.** Students will learn about different types of maintenance (corrective, adaptive, perfective, preventive) and the activities involved in each. The curriculum covers techniques for software refactoring, reverse engineering, and re-engineering. Emphasis is placed on maintaining software quality and dealing with technical debt during the maintenance phase. Students will also explore strategies for software evolution, including adding new features and adapting to changing business needs.",
          "concepts_covered": [
            "**Introduction to Software Maintenance: Importance and challenges**",
            "**Types of Software Maintenance: Corrective, Adaptive, Perfective, Preventive**",
            "**Maintenance Activities: Bug fixing, enhancements, upgrades, migrations**",
            "**Software Refactoring: Principles, techniques, and best practices for improving code quality**",
            "**Technical Debt: Identification, management, and impact on maintainability**",
            "**Reverse Engineering: Understanding existing software systems**",
            "**Re-engineering: Restructuring and rewriting part or all of a software system**",
            "**Software Evolution: Planning and managing changes to software over time**",
            "**Impact Analysis: Assessing the effect of changes on a software system**",
            "**Configuration Management and Version Control in Maintenance**",
            "Software documentation for maintenance"
          ],
          "concepts_not_covered": [
            "Legacy system modernization in depth",
            "Cost estimation for maintenance projects",
            "Legal and ethical issues in software maintenance",
            "AI-assisted software maintenance"
          ]
        }
      },
      {
        "week_id": 7,
        "course_id": 3,
        "order": 7,
        "title": "**Week 7: Agile Project Management - Advanced Topics**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This week delves into advanced topics in Agile project management.** Building upon the fundamentals of Scrum, students will explore scaled agile frameworks (SAFe, LeSS), Kanban for software development, and hybrid agile approaches. The curriculum covers advanced techniques for backlog management, release planning, and managing distributed agile teams. Emphasis is placed on agile metrics, risk management in agile projects, and the role of leadership in fostering agile practices.",
          "concepts_covered": [
            "**Scaling Agile: Introduction to Scaled Agile Framework (SAFe) and Large-Scale Scrum (LeSS)**",
            "**Kanban for Software Development: Principles, practices, and flow management**",
            "**Hybrid Agile Approaches: Combining agile and traditional methodologies**",
            "**Advanced Backlog Management: Prioritization techniques, story mapping, and backlog refinement at scale**",
            "**Release Planning in Agile: Planning horizons, release trains, and dependency management**",
            "**Managing Distributed Agile Teams: Communication strategies, collaboration tools, and cultural considerations**",
            "**Agile Metrics: Velocity, burndown charts, cumulative flow diagrams, and value stream mapping**",
            "**Risk Management in Agile Projects: Identifying, assessing, and mitigating risks in iterative development**",
            "**Agile Leadership: Servant leadership, coaching, and fostering self-organizing teams**",
            "Agile Contracts and Procurement",
            "The role of the Product Owner and Scrum Master in advanced scenarios"
          ],
          "concepts_not_covered": [
            "Agile portfolio management in detail",
            "Agile transformation strategies at organizational level",
            "Specific tool configurations for scaled agile",
            "Psychological aspects of agile team dynamics in depth"
          ]
        }
      },
      {
        "week_id": 8,
        "course_id": 3,
        "order": 8,
        "title": "**Week 8: Software Engineering Best Practices and Ethics**",
        "estimated_hours": 25,
        "LLM_Summary": {
          "summary": "**This final week integrates software engineering best practices and ethical considerations.** Students will revisit topics such as code quality, documentation, and continuous improvement. The curriculum emphasizes the importance of ethical practices in software development, including data privacy, security, intellectual property, and responsible use of technology. Case studies and discussions will explore ethical dilemmas in software engineering and the role of professional codes of conduct.",
          "concepts_covered": [
            "**Revisiting Software Engineering Best Practices: Code quality, documentation, testing, and automation**",
            "**Principles of Software Craftsmanship**",
            "**Continuous Improvement in Software Engineering: Retrospectives, learning from failures, and adopting new practices**",
            "**Ethical Considerations in Software Engineering: Data privacy, security, and confidentiality**",
            "**Intellectual Property: Software licensing, patents, and copyrights**",
            "**Responsible Use of Technology: Bias in algorithms, accessibility, and environmental impact**",
            "**Professional Codes of Conduct: IEEE Code of Ethics, ACM Code of Ethics**",
            "**Ethical Dilemmas in Software Engineering: Case studies and discussions**",
            "**The Social Impact of Software Engineering**",
            "Legal Frameworks and Compliance in Software Development"
          ],
          "concepts_not_covered": [
            "Detailed legal analysis of software contracts",
            "Advanced topics in cyber ethics",
            "Specific industry regulations and compliance standards in depth",
            "Philosophical foundations of software ethics"
          ]
        }
      }
    ],
    "lectures": [
      {
        "lecture_id": 1,
        "week_id": 1,
        "order": 1,
        "title": "**Lecture 1: The Nature of Software and Software Engineering**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=hKm_rh1RTJQ",
        "content_transcript": "[Music] welcome to this course on software engineering we all know the importance of software today but we need to know how to build such systems and how such systems are built what do we have to do in terms of thinking about users how do we do the coding how do we do the testing and so on and so forth so this course is a primer to understanding how to design such software systems how to do some of the implementation and some aspects of the testing and so on so what are the expectations from you as a learner you are expected to put in at least six hours per week on the course so that you can get the maximum out of it and from our side we will ensure that there are activities and there are dialogues that happen throughout so that you do not feel that it is one long monolithic video that you are watching so what is software engineering so if you look at the history of software engineering it started off as an art so you had good programmers who wrote good code and you had bad programmers who did not write good code and over time the expertise of these good programmers they were documented over time which led to processes models and strategies for effective software development and thus the field of software engineering was born so in this course we will be looking at three important categories of topics so one is the software processes so what are different processes which are used in software development you will be learning about processes like the waterfall model the agile model and what are common practices in these models which are used in the industry a second category of topics is tools right so what are tools which software teams use to build software for example what tools are used to capture requirements how is software planning done how is development done how is testing done so throughout the course you will be learning about different tools which are used in the software development process and third we will also be talking about code we'll be talking about how you can organize your code what are best practices for writing clean and effective code this course has been created using a learner centric mooc model what does that mean it means that instead of simply having all the lectures in the beginning followed by all the assignments followed by the exams what we have tried to do is to interleave these in a way that is meaningful for you to maintain your engagement for example there might be a video in which there might be a pause where we ask you to think about something and maybe write down your thoughts so this pause is very important for learning and that is called the reflection spot similarly the videos might be short and immediately after the video we might want you to do some activity ok so these are learning by doing activities again which are very important for learning then there will be discussion forums in which we will post questions to focus your discussion so that you can have a focused discussion instead of a scattered one and finally there will be lot of resources which will cater to your exploration in the direction of your interest for example some people may be more interested in coding whereas some others may be more interested in how a software behaves actually in the field whereas the third set of people may be more interested in talking to users of the software another key aspect of this course is the course project and through this course project you will be able to go through the entire software development lifecycle so a software engineering course it can be very theoretical and the best way to get an understanding of what all you learn is to apply the processes the practices the tools in building an actual software so in each week you will have some intermediate milestones which you need to complete to progress towards the goal of building a software product so we hope you have a great time in this course and happy learning you [Music] we are all familiar with buying things on an online platform like amazon we are familiar with ordering things online and we are not surprised when the goods land up at our doorstep behind it there is a huge system which actually makes this happen so there is the vendor who is putting the things into the system there is a logistics person who is trying to handle ensure that the item reaches you in a timely manner and so on now how do you think this amazon system was built do you think it was built in one monolithic way so in most cases software is not built as a monolithic system but it is built incrementally one feature after the other and moreover often times we do not know at the start what all features are required to be implemented yes that is a good point so we incrementally build certain features into the application and the one the people who built amazon would have also done the same thing and even for building these features software teams have to ensure that they are divided into manageable components so components are a way of breaking the complexity of a system into manageable parts so that different teams can work on different components of the system and put everything together in a timely manner also everyone need not know the workings of all the components as long as i know that if i ask some response from a component and i know what sort of response it will give me that is sufficient for me to proceed with my work so the components can hide the complexity of the implementation and provide an interface to others who want to know what the component does now let us think about the components in the amazon system what do you think are some of the components can take a minute pause here think about what could the components in the amazon system be if you were the one of the developers of that system so i think one major component in the amazon system is of course their inventory management system so they keep track of their inventory in such an intelligent way so learners you might be wondering what do we actually mean by any by intelligent so let's think about what inventory management is so inventory management is the act of measuring the amount location pricing the mix of products available on amazon so when we go to the amazon home page we see that our inventory gets updated based on the current purchasing and seasonal trends and fluctuating customer demand and logistics and analytics also play a large part in inventory management so it is very interesting to see how my amazon home page could be very different from yours the reason being amazon customizes my home page based on my shopping and viewing history another component can be their payment gateway so the payment gateway is another component which offers ease of payment for both buyer and the seller so payment gateway is a service that authorizes the electronic payments like online banking debit cards cash cards etc so the payment gateway acts as a middleman between the bank and the merchant's website or application when a user wishes to make a payment the amazon website sends the encrypted card information to the payment gateway then the payment gateway confirms the validity of these details with the bank and the required amount of money gets transferred from the user's account to the amazon account so we looked at two components of the amazon system the inventory management and the payment gateway i am sure you can think of more components that makes up such a system so in this video we looked at components of a large system such as amazon and we looked a little more closely at two components the inventory management and the payment gateway the main thing that we have learnt is that nobody builds a system all at once for the entire functionality of the system so a system a large system is broken down into components and there are different teams that work on those different components each of these components now is called a module and they can be developed separately and integrated together later of course there is a lot of complexity in doing so because you need these modules to be able to talk to each other and so on and that we will see in the following videos you ",
        "duration_minutes": 45,
        "keywords": [
          "software engineering",
          "software processes",
          "tools",
          "inventory management",
          "payment gateway",
          "system components",
          "module integration"
        ]
      },
      {
        "lecture_id": 2,
        "week_id": 1,
        "order": 2,
        "title": "**Lecture 2: Software Development Lifecycle Models - A Detailed Comparison**",
        "resource_type": "pdf",
        "resource_url": "SE 1.pdf",
        "content_extract": "**Software engineering is a discipline that encompasses the design, development, testing, and maintenance of software systems.** [11] It involves breaking down complex systems into manageable components to ensure efficiency and reliability [11]. For instance, large-scale platforms like Amazon are composed of various modules such as inventory management and payment gateways [11]. Each component is designed to perform a specific function while integrating seamlessly with others [11]. **The software development lifecycle (SDLC) provides a structured approach to software creation, encompassing requirement specification, design, development, testing, and maintenance.** [11] Different development models offer various perspectives on how to approach these phases [11]. **The waterfall model is a sequential process where each phase must be completed before the next begins.** [11] Although straightforward, it has drawbacks such as increased costs and extended timelines if changes are needed later [11]. Clients may not fully articulate their needs upfront, and designers might struggle to identify the most practical solution [11]. **Prototyping addresses these issues by creating a preliminary model to gather feedback.** [11] Although it helps clarify requirements and technical challenges, it can increase development costs and introduce bugs later [11]. **The spiral model adopts an iterative approach where software is incrementally built and refined based on feedback.** [11] It combines iterative development with risk analysis, making it suitable for complex and high-risk projects [12]. **Agile methodologies emerged to address the limitations of plan-driven models like waterfall.** [11] The Agile Manifesto emphasizes four core values: individuals and interactions over processes and tools, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan [11]. Agile development emphasizes incremental progress through iterative cycles [11]. Popular frameworks include Extreme Programming (XP), Scrum, and Kanban [11]. Agile practices like user stories, sprints, and daily stand-ups facilitate continuous delivery and adaptability [11]. **Test-driven development (TDD) ensures code correctness by writing tests before implementing functionality.** [11] The choice between agile and plan-driven approaches depends on project characteristics [11]. If precise specifications, regulatory compliance, or long product lifecycles are essential, plan-driven models are preferable [11]. Conversely, agile methods are ideal for projects requiring flexibility, rapid feedback, and evolving requirements [11]. Other models like the V-Model emphasize the relationship between development and testing phases, with a verification and validation activity corresponding to each development stage. The Incremental model builds the system in small increments, with each increment being tested and integrated. Understanding the strengths and weaknesses of each model is crucial for selecting the most appropriate one for a given project context. Factors such as project size, complexity, team experience, and stakeholder involvement should be considered in the selection process.",
        "duration_minutes": 90,
        "keywords": [
          "SDLC",
          "waterfall",
          "prototype",
          "spiral",
          "V-Model",
          "incremental",
          "plan-and-document",
          "agile",
          "testing methodologies",
          "software maintenance",
          "process tailoring"
        ]
      },
      {
        "lecture_id": 3,
        "week_id": 1,
        "order": 3,
        "title": "**Lecture 3: Introduction to Agile Methodologies: Scrum and Kanban**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=XU0llRltyFM",
        "content_transcript": "Welcome to this lecture on Agile methodologies. In today's fast-paced software development world, the ability to adapt to changing requirements and deliver value quickly is paramount. Agile methodologies provide a set of principles and frameworks that enable teams to do just that. We'll be focusing on two of the most popular Agile frameworks: Scrum and Kanban. Scrum is an iterative and incremental framework for managing product development. It emphasizes teamwork, accountability, and iterative progress towards a well-defined goal. The core of Scrum is the sprint, a short, time-boxed period, typically two weeks, during which a potentially shippable product increment is created. Each sprint follows a set of ceremonies: Sprint Planning, where the team selects work from the product backlog for the upcoming sprint; Daily Stand-up, a brief daily meeting for the team to synchronize and plan the next 24 hours; Sprint Review, where the team presents the work done during the sprint to stakeholders; and Sprint Retrospective, where the team reflects on the past sprint and identifies areas for improvement. Key roles in Scrum include the Product Owner, who is responsible for maximizing the value of the product; the Scrum Master, who facilitates the Scrum process and helps the team remove impediments; and the Development Team, a self-organizing group of professionals who do the work of delivering the increment. Kanban, on the other hand, is a lean methodology focused on visualizing workflow, limiting work in progress (WIP), and continuously improving flow. Unlike Scrum, Kanban does not prescribe fixed iterations or specific roles. The primary tool in Kanban is the Kanban board, which visually represents the different stages of the workflow. Work items move through these stages, and the WIP limits ensure that the team focuses on completing tasks before starting new ones. The principles of Kanban include visualizing the workflow, limiting WIP, managing flow, making process policies explicit, and improving collaboratively. Both Scrum and Kanban are based on the Agile Manifesto principles and aim to deliver value to the customer frequently and adaptively. While Scrum provides a more structured framework with defined roles and events, Kanban offers more flexibility and is often used for continuous flow environments or to improve existing processes. Many teams also adopt hybrid approaches, combining elements of both frameworks to best suit their needs. Understanding the core concepts and principles of Scrum and Kanban is essential for anyone involved in modern software development.",
        "duration_minutes": 52,
        "keywords": [
          "agile",
          "scrum",
          "sprint",
          "product backlog",
          "sprint planning",
          "daily stand-up",
          "sprint review",
          "sprint retrospective",
          "product owner",
          "scrum master",
          "development team",
          "kanban",
          "work in progress",
          "workflow visualization"
        ]
      },
      {
        "lecture_id": 4,
        "week_id": 2,
        "order": 1,
        "title": "**Lecture 4: Requirement Gathering and Analysis - Advanced Techniques**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=L9-CUa0BlLk&t=55s",
        "content_transcript": "foreign [Music] we looked at requirement Gathering and Analysis and we also looked at how we need to consider the primary secondary and tertiary users of a system now that we have identified these different types of users the question is now how do we gather or identify requirements from these users do we just talk to users or are there other ways to gather these requirements so let's reflect on this question for a moment and let's take the example of the Amazon Seller portal that we looked at in the previous video let's say that it's the early days of Amazon and you have been commissioned by Amazon to build this Amazon Seller portal so here are some of the users that we identified in the previous lectures so we have independent sellers we have a sales team or a sales manager of different companies we we have people from the advertising Department we have Logistics or shipping company managers of course we have buyers and we have Banks so the these are different users of the system so now the question is what are ways in which we can gather requirements from these different users for developing a seller port you can pause this video and think about these answers before proceeding so there are different requirement collection techniques and let's look at them one by one so one type of requirement collection technique is what is known as a questionnaire so questionnaire is nothing but a series of questions which are designed to elicit specific information from users and I'm sure most of you would be familiar with questionnaires as you would have filled such question as as part of you know different courses and the program as well and these questions can be of different types can be a simple yes or no question maybe you have to choose from a set of answers or it can be a longer response or a comment and questionnaires are good for getting answers to specific questions from a large group of people who are usually spread across a wide geographical area so for example you can send questionnaires to sales team managers of several mobile companies and you can ask them questions like you know what percentage of your inventory do you sell online or you know what are main difficulties you encounter\n[13] in selling your product online so these answers to these specific questions can help us elicit requirements from different users and an important thing to note is that this should be used in conjunction with other techniques other requirement Gathering techniques which we'll see in the next slide so another important requirement Gathering technique is interviews right and interviews it involves asking someone a set of questions it is often face to face but it need not be we can use telephonic interviews or even online interviews to ask questions and interviews are broadly classified as structured unstructured or semi-structured interviews depending on how rigorously the interviewer sticks to a prepared set of questions so an interview can be structured which is nothing but a fixed set of questions and the interviewer asks those questions and elicit responses and in an in an unstructured interview the interviewer doesn't really know what type of questions to ask because they don't know what the user does or what exactly their needs are so in such cases we can ask users broad questions and based on their responses we can probe further into specific aspects so what are purposes of these interviews one is we it helps us get or understand issues which people have and it can be used early in the requirement Gathering process to elicit different scenarios so for example we can conduct interviews with independent Sellers and ask them you know what are different platforms which you use to sell your products this is a fairly open-ended question and they might give answers like we use WhatsApp Instagram and then we can probe them and ask you know what are disadvantages or advantages of these portals and they might say well I get customers you know it's easy to get customers but then tracking orders you know tracking payments tracking my inventory what are different selling options all of this is a huge overhead right so from from these questions we can elicit requirements which involve tracking orders you know tracking payments and all of these things so now we looked at interviews and one drawback of interviews is that it offers only one perspective and an alternative can be to get a group of stakeholders to discuss issu\n[14] es and requirements and the the advantages of using focus groups are one is it helps us gain consensus so if different groups of stakeholders if they highlight the same issue or the same concern then we know that this is a key requirement which we need to build into our system and this is also useful for highlighting areas of conflict or disagreement so different groups of people might not agree and this helps us get a nuanced understanding of the needs of different stakeholders so let's take an example from the Amazon Seller portal itself so we can conduct focus groups with you know different sales team Managers from different verticals and there might be different expectations from different Industries so for example a mobile sales team might be very interested in understanding what is the sales summary at the launch of a particular mobile whereas departments like furniture they might be more interested in the sales summary of the last 30 days so from such focus groups we can elicit requirements like such as the summary of the sales in the past X days or in a specific day so these are some requirements which can be elicited from focus groups so in the previous requirement Gathering techniques we looked at interviews focus groups in these techniques we are asking people questions but one thing to remember is that what people say is often different from what they do and it is very difficult for humans to actually explain what they do or describe accurately how they do a particular task so for example how do buyers buy online what are they looking for in a product this might not be very easy to articulate and hence an important technique which we can use is observe users right it involves spending time with stakeholders as they go about doing their day-to-day tasks and observing their work in their natural setting and this involves you know shadowing a stakeholder making notes occasionally asking them questions but primarily observing what they do so let's take the example of a seller the seller portal so one way in which we can gather requirements is to look at how people sell in physical shops so for example shopkeepers or customers they give recommendations the customer might ask the shopkeeper for a new prod\n[15] uct and or the shopkeeper might ask the customer to try a new product customer feedback is also very important the shop owner they appreciate feedback about a product which they sold to their custom so these can be translated into the online setting as well in the form of recommendations as well as getting timely customer feedback another type of requirement Gathering technique is documentation so there are places where you know which helps several procedures and rules for doing a particular task and these might be written down in manuals or documents or there might be steps which are involved in performing in an activity or there might be regulations which might be governing a task so in our case in case of a seller portal Bank regulations are an important requirement to consider so for example how can you add sellers bank accounts to your portal or how frequently can you deposit money to seller accounts what are practices of other online marketplaces all these can be gathered from different documents or different procedures and regulations so here's a summary of the requirement Gathering techniques which we saw till now so we looked at question as interviews focus groups observations and documentations and each of them serve a specific purpose for example questionnaires are good for answering specific questions and interviews are good for exploring issues and for which we do not really have the answers for focus groups are important for collecting multiple viewpoints and observations are good for understanding the context in which a user performs a particular task and then we looked at documentation which involves procedures regulations and standards so we looked at several requirement Gathering techniques and using thought experiments on how we can gather requirements we were able to identify several requirements for the Amazon seller put for example we understood that a catalog and inventory are necessary and it is essential for us to track different things like orders payments the sales as well as customer feedback so to conclude let us look at some basic requirement Gathering guidelines so first we need to focus on identifying stakeholders needs and we need to involve all the stakeholder groups the primar\n[16] y secondary as well as the tertiary users because each of these types of users have different needs and requirements and it is advisable to use a combination of different requirement Gathering techniques mainly because different techniques have different purposes and we need to use them according to our needs another important point to consider is to run a pilot session if possible to ensure that your data Gathering session is likely to go as planned many a times especially for questionnaires you might miss out on a particular question you might have wrong options might be having missing options so it is difficult to go back and ask users to fill the survey again and hence it's important to test your Gathering techniques before you actually go about and gather requirements and finally data Gathering is expensive and it is time consuming because you have to talk to different types of users and once you get their responses you need to analyze them and all of this is a time consuming and effort consuming activity and hence often at times we have to be pragmatic and we have to make certain complexes ",
        "duration_minutes": 50,
        "keywords": [
          "requirements",
          "stakeholders",
          "interviews",
          "questionnaires",
          "observation",
          "focus groups",
          "documentation",
          "elicitation techniques",
          "pilot session"
        ]
      },
      {
        "lecture_id": 5,
        "week_id": 2,
        "order": 2,
        "title": "**Lecture 5: Documenting Requirements: Use Cases and User Stories**",
        "resource_type": "pdf",
        "resource_url": "SE 2.pdf",
        "content_extract": "**Software engineering is a structured approach to designing, developing, testing, deploying, and maintaining software systems that meet specified requirements with efficiency and reliability.** [17] Effective requirements gathering involves engaging stakeholders through interviews, surveys, and use-case analysis to capture both explicit needs and implicit expectations [17]. Once requirements are gathered, they need to be documented clearly and concisely. Two popular methods for this are use cases and user stories. **Use cases describe the interaction between an actor (typically a user) and the system to achieve a specific goal.** [18] A use case description typically includes a name, a brief description, actors involved, preconditions (what must be true before the use case can start), the main flow of events (the steps the actor and system take), alternative flows (different scenarios or paths), postconditions (what is true after the use case ends), and any exceptions (errors or issues that might occur) [18]. Use case diagrams, using UML notation, provide a visual representation of the system's functionality from the user's perspective, showing actors and the use cases they interact with. **User stories, commonly used in Agile methodologies, are short, simple descriptions of a feature told from the perspective of the person who desires the new capability, usually following the format: 'As a [type of user], I want [some goal] so that [some reason/benefit]'.** [19] Good user stories follow the INVEST criteria: Independent, Negotiable, Valuable, Estimable, Small, and Testable [19]. User stories are often written on index cards or in a backlog management tool and are used as the basis for planning and discussion within the development team. Acceptance criteria are added to user stories to define the boundaries and ensure that the story is implemented correctly. Both use cases and user stories serve to ensure a shared understanding of the system's requirements among stakeholders and the development team, but they differ in their level of detail and formality, with use cases typically providing more comprehensive documentation and user stories favoring brevity and flexibility.",
        "duration_minutes": 55,
        "keywords": [
          "SRS",
          "functional",
          "non-functional",
          "use cases",
          "actors",
          "scenarios",
          "user stories",
          "INVEST",
          "acceptance criteria",
          "requirements documentation"
        ]
      },
      {
        "lecture_id": 6,
        "week_id": 2,
        "order": 3,
        "title": "**Lecture 6: Functional vs. Non-Functional Requirements in Detail**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=Kt9gYHiYtFw",
        "content_transcript": "In our previous lectures, we touched upon the distinction between functional and non-functional requirements. In this session, we will delve deeper into these two crucial categories of software requirements. **Functional requirements define what the system should do.** [17] They describe the specific behaviors or functions that the system must perform. These are often expressed in the form of actions, processes, or data manipulations that the system needs to support. Examples of functional requirements include: 'The user shall be able to log in with a username and password,' 'The system shall allow customers to add items to their shopping cart,' and 'The application shall generate a sales report.' These requirements are typically derived directly from user needs and business goals. On the other hand, **non-functional requirements specify how the system should perform.** [17] They describe the qualities or constraints on the system, such as its performance, security, usability, reliability, scalability, and maintainability. Examples of non-functional requirements include: 'The system shall respond to user requests within 3 seconds,' 'The application shall be secure against SQL injection attacks,' 'The user interface shall be intuitive and easy to navigate,' 'The system shall be available 99.9% of the time,' 'The application shall be able to handle 1000 concurrent users,' and 'The codebase shall be well-documented and easy to understand.' Non-functional requirements are equally important as they ensure that the system not only performs the required functions but also does so in a way that meets user expectations and business needs regarding its quality attributes. Often, non-functional requirements can be further categorized. For instance, performance requirements specify speed, throughput, and response time; security requirements detail measures to protect data and prevent unauthorized access; usability requirements focus on the ease of use and learning; reliability requirements define the system's ability to operate without failure; and scalability requirements address the system's capacity to handle increased load. Effectively capturing and documenting both functional and non-functional requirements is critical for the success of any software project, as they guide the design, implementation, testing, and deployment phases.",
        "duration_minutes": 48,
        "keywords": [
          "functional requirements",
          "non-functional requirements",
          "performance",
          "security",
          "usability",
          "reliability",
          "scalability",
          "maintainability",
          "requirements analysis"
        ]
      },
      {
        "lecture_id": 7,
        "week_id": 3,
        "order": 1,
        "title": "**Lecture 7: Software Architecture: Styles and Patterns**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=m4_0MjT1I4I",
        "content_transcript": "Welcome to our lecture on software architecture styles and patterns. Software architecture serves as the blueprint for a software system, providing a high-level structure of its components, their relationships, and the principles governing their design and evolution. Choosing the right architectural style is fundamental to addressing a system's functional and non-functional requirements. There are several common architectural styles, each with its own strengths and weaknesses. The **monolithic architecture** is a traditional approach where all components of the application are tightly coupled and deployed as a single unit. While simple to develop initially, it can become complex to manage and scale as the application grows. The **layered architecture** organizes the system into hierarchical layers, such as presentation, business logic, and data access. This promotes separation of concerns and makes the system easier to understand and maintain. The **client-server architecture** divides the system into clients that request services and servers that provide them. This is widely used in web applications and distributed systems. The **microservices architecture** structures an application as a collection of small, independent services communicating over a network. This offers benefits like scalability, resilience, and technology diversity but introduces complexity in managing distributed systems. The **event-driven architecture** focuses on the production and consumption of events, enabling loose coupling and asynchronous communication between components. Beyond architectural styles, **architectural patterns** are reusable solutions to common problems in software architecture. Examples include Model-View-Controller (MVC) for separating presentation, data, and control logic; Publish-Subscribe for enabling one-to-many dependencies between components; and REST (Representational State Transfer) for designing scalable web services. Similarly, **design patterns** are reusable solutions to common design problems at a lower level of abstraction, focusing on interactions between objects and classes. Creational patterns deal with object creation mechanisms, structural patterns with the composition of classes and objects, and behavioral patterns with the communication and interaction between objects. Understanding and applying appropriate architectural styles and design patterns is crucial for building robust, scalable, and maintainable software systems that meet their requirements effectively.",
        "duration_minutes": 58,
        "keywords": [
          "software architecture",
          "architectural styles",
          "monolithic",
          "layered",
          "client-server",
          "microservices",
          "event-driven",
          "architectural patterns",
          "design patterns",
          "MVC",
          "REST",
          "publish-subscribe"
        ]
      },
      {
        "lecture_id": 8,
        "week_id": 3,
        "order": 2,
        "title": "**Lecture 8: Software Design Principles: SOLID and Design Patterns**",
        "resource_type": "pdf",
        "resource_url": "SE 3.pdf",
        "content_extract": "**Software engineering is a systematic, disciplined, and quantifiable approach to the development, operation, and maintenance of software.** [20] The system design phase translates the requirements into a technical blueprint, outlining the software architecture, data flow, and component interactions [21]. Key **design principles** guide this process, leading to software that is maintainable, scalable, and robust [17]. The **SOLID principles** are a set of five principles that aim to make software designs more understandable, flexible, and maintainable [22]. These include: **Single Responsibility Principle (SRP)**: A class should have only one reason to change [22]. **Open-Closed Principle (OCP)**: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. **Liskov Substitution Principle (LSP)**: Subtypes must be substitutable for their base types. **Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use. **Dependency Inversion Principle (DIP)**: Depend upon abstractions, not concretions. In addition to these principles, **design patterns** provide reusable solutions to common problems in software design [23]. They represent best practices and common solutions that have been proven effective over time. Design patterns are typically categorized into three main types: **Creational patterns** (e.g., Singleton [24], Factory Method [25], Builder) that deal with object creation; **Structural patterns** (e.g., Adapter [25], Composite, Decorator) that deal with the composition of classes and objects; and **Behavioral patterns** (e.g., Observer [25], Strategy, Command) that deal with the communication and interaction between objects [23]. Applying these principles and patterns helps in creating software that is easier to understand, modify, and test, ultimately reducing development costs and improving software quality [23, 26]. The choice of appropriate design patterns depends on the specific problem being solved and the context of the software system.",
        "duration_minutes": 52,
        "keywords": [
          "software design",
          "design principles",
          "SOLID",
          "Single Responsibility Principle",
          "Open-Closed Principle",
          "Liskov Substitution Principle",
          "Interface Segregation Principle",
          "Dependency Inversion Principle",
          "design patterns",
          "creational patterns",
          "structural patterns",
          "behavioral patterns"
        ]
      },
      {
        "lecture_id": 9,
        "week_id": 4,
        "order": 1,
        "title": "**Lecture 9: Fundamentals of Software Testing: Levels and Types**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=oR9b7W0yeyQ",
        "content_transcript": "Welcome to this lecture on the fundamentals of software testing. Testing is a critical phase in the software development lifecycle, aimed at ensuring the quality, reliability, and correctness of the software. It involves executing the software to find defects and verifying that it meets the specified requirements. There are different **levels of testing**, each focusing on a specific scope. **Unit testing** is the first level, where individual components or modules of the software are tested in isolation to verify that they function correctly [27]. This is typically done by developers. **Integration testing** focuses on verifying the interactions between different integrated components or modules [27]. The goal is to test the interfaces and ensure that data flows correctly between them. **System testing** involves testing the complete and integrated software system [27]. It aims to evaluate the system's compliance with the specified functional and non-functional requirements. **Acceptance testing** is performed by the end-users or stakeholders to determine whether the system meets their needs and is ready for deployment [27]. This often includes User Acceptance Testing (UAT). Besides these levels, there are various **types of testing** based on the purpose or approach. **Functional testing** verifies the software against the functional requirements, ensuring that it performs as expected. **Non-functional testing** evaluates aspects like performance, security, usability, and reliability [17]. **Black-box testing** involves testing the software without knowledge of its internal structure or code, focusing on the inputs and outputs. **White-box testing**, on the other hand, involves testing based on the internal structure and implementation details of the software, often requiring access to the source code. **Regression testing** is performed after making changes to the software (e.g., bug fixes or enhancements) to ensure that the changes have not introduced new defects or adversely affected existing functionality [28]. Understanding these different levels and types of testing is essential for developing a comprehensive testing strategy that covers all critical aspects of the software system and ensures its quality.",
        "duration_minutes": 55,
        "keywords": [
          "software testing",
          "unit testing",
          "integration testing",
          "system testing",
          "acceptance testing",
          "functional testing",
          "non-functional testing",
          "black-box testing",
          "white-box testing",
          "regression testing",
          "testing levels",
          "testing types"
        ]
      },
      {
        "lecture_id": 10,
        "week_id": 4,
        "order": 2,
        "title": "**Lecture 10: Software Testing Techniques: Black-Box and White-Box**",
        "resource_type": "pdf",
        "resource_url": "SE 4.pdf",
        "content_extract": "**Software engineering is a systematic and disciplined approach to the design, development, testing, deployment, and maintenance of software systems.** [23] **Testing is an integral part of software engineering aimed at validating the correctness, performance, and security of the system.** [29] Various **testing techniques** are employed to achieve thorough coverage. These techniques can be broadly classified into **black-box testing** and **white-box testing**. **Black-box testing** involves testing the software without any knowledge of its internal structure or code [30]. Testers treat the software as a 'black box,' focusing solely on the inputs and outputs and verifying that the software behaves according to the specified requirements. Common black-box testing techniques include: **Equivalence Partitioning**, which divides the input data into groups (partitions) and tests one value from each partition, assuming that if one value in the partition works, all others will as well; **Boundary Value Analysis**, which focuses on testing the values at the edges of input and output domains, as these are often where defects occur; **Decision Table Testing**, which is used when the logic of the software involves multiple conditions, creating tables to cover all possible combinations of conditions and actions; **State Transition Testing**, which is applicable when the software has different states and transitions between them, testing the validity of these transitions; and **Use Case Testing**, which designs test cases based on the use cases of the system, covering the different scenarios of user interaction. On the other hand, **white-box testing** involves testing the software with knowledge of its internal structure and code [30]. Testers examine the source code to identify paths to test. Common white-box testing techniques include: **Statement Coverage**, which aims to ensure that every statement in the code is executed at least once; **Branch Coverage**, which aims to ensure that every possible outcome (true or false) of each decision point (e.g., if statements, loops) is tested at least once [31]; and **Path Coverage**, which aims to execute all possible paths through the code. White-box testing helps in identifying defects in the code logic and ensuring that all parts of the code are exercised. In practice, a combination of both black-box and white-box testing techniques is often used to provide comprehensive test coverage and ensure the quality of the software.",
        "duration_minutes": 60,
        "keywords": [
          "software testing",
          "testing techniques",
          "black-box testing",
          "white-box testing",
          "equivalence partitioning",
          "boundary value analysis",
          "decision table testing",
          "state transition testing",
          "use case testing",
          "statement coverage",
          "branch coverage",
          "path coverage"
        ]
      },
      {
        "lecture_id": 11,
        "week_id": 5,
        "order": 1,
        "title": "**Lecture 11: Software Deployment Strategies and Tools**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=QJ11KjQu4_o",
        "content_transcript": "Welcome to our lecture on software deployment strategies and tools. Once software has been developed and tested, the next crucial step is to deploy it to the production environment where it becomes available to users. There are various **deployment strategies**, each with its own advantages and disadvantages. **Blue-green deployment** involves maintaining two identical production environments, one live (blue) and one idle (green). The new version of the software is deployed to the green environment, tested, and then traffic is switched from blue to green, allowing for rapid rollback if issues arise. **Canary releases** involve gradually rolling out the new version to a small subset of users while the majority remain on the old version. This allows for monitoring the impact of the new release on a limited audience before a full rollout. **Rolling updates** involve incrementally updating the software on a set of servers, one after the other, ensuring that the service remains available during the process. **A/B testing** is a deployment strategy often used for feature releases, where two versions of a feature are deployed to different groups of users to see which performs better based on certain metrics. To facilitate these deployments, a variety of **tools** are used. **Infrastructure as Code (IaC)** tools like Terraform and Ansible allow for managing infrastructure in a declarative way, making deployments consistent and repeatable. **Containerization technologies** such as Docker package applications and their dependencies into containers, ensuring consistent execution across different environments. **Orchestration platforms** like Kubernetes automate the deployment, scaling, and management of containerized applications. **Continuous Integration and Continuous Deployment (CI/CD) tools** like Jenkins, GitLab CI, and Travis CI automate the build, test, and deployment pipelines, enabling frequent and reliable releases. Monitoring tools like Prometheus and Grafana, and logging tools like the ELK stack (Elasticsearch, Logstash, Kibana), are essential for tracking the health and performance of deployed applications and identifying any issues that may arise.",
        "duration_minutes": 50,
        "keywords": [
          "software deployment",
          "deployment strategies",
          "blue-green deployment",
          "canary releases",
          "rolling updates",
          "A/B testing",
          "infrastructure as code",
          "Terraform",
          "Ansible",
          "containerization",
          "Docker",
          "orchestration",
          "Kubernetes",
          "CI/CD",
          "Jenkins",
          "monitoring",
          "Prometheus",
          "logging",
          "ELK stack"
        ]
      },
      {
        "lecture_id": 12,
        "week_id": 5,
        "order": 2,
        "title": "**Lecture 12: Introduction to DevOps: Principles and Practices**",
        "resource_type": "pdf",
        "resource_url": "https://www.redhat.com/en/resources/what-is-devops-pdf",
        "content_extract": "**DevOps is a set of practices that automates the processes between software development (Dev) and IT operations (Ops) teams.** [12] It emphasizes collaboration and communication between these historically siloed teams, with the goal of delivering software faster and more reliably. The core **principles of DevOps** revolve around automation, continuous integration, continuous delivery, monitoring, collaboration, and a culture of shared responsibility. **Automation** is a key aspect, involving automating repetitive tasks in the software development and deployment pipeline, such as building, testing, and deploying code. **Continuous Integration (CI)** is a practice where developers regularly merge their code changes into a central repository, after which automated builds and tests are run. This helps in detecting and fixing integration issues early. **Continuous Delivery (CD)** extends CI by automating the release of code changes to production or a production-like environment. **Monitoring** involves actively tracking the performance and health of the application and infrastructure in production, allowing for quick detection and resolution of issues. **Collaboration** between development and operations teams is crucial, breaking down silos and fostering a shared understanding of goals and challenges. A **culture of shared responsibility** means that both teams are accountable for the entire software lifecycle, from development to operation. **Key practices in DevOps** include using version control for all code and configurations, employing CI/CD pipelines, practicing infrastructure as code, automating testing at all levels, continuously monitoring and logging systems, and fostering a collaborative and feedback-driven culture. DevOps aims to shorten the development lifecycle, increase the frequency of deployments, and provide faster feedback, ultimately leading to higher quality software and greater customer satisfaction. Tools like Git, Jenkins, Docker, Kubernetes, Ansible, and Prometheus are commonly used in DevOps workflows to implement these principles and practices.",
        "duration_minutes": 58,
        "keywords": [
          "devops",
          "continuous integration",
          "continuous delivery",
          "automation",
          "monitoring",
          "collaboration",
          "infrastructure as code",
          "CI/CD pipeline",
          "git",
          "jenkins",
          "docker",
          "kubernetes",
          "ansible",
          "prometheus",
          "shared responsibility"
        ]
      },
      {
        "lecture_id": 13,
        "week_id": 6,
        "order": 1,
        "title": "**Lecture 13: Types of Software Maintenance and Maintenance Process**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=VTT9mSg7_p0",
        "content_transcript": "Welcome to our lecture on the types of software maintenance and the maintenance process. Software maintenance is an essential part of the software lifecycle that occurs after the software has been deployed and is in operation. It involves modifying the existing software to correct errors, improve performance, or adapt to a changing environment. There are four primary **types of software maintenance**: **Corrective maintenance** focuses on fixing defects or bugs that were not discovered during the testing phases and are found by users in the production environment. These issues need to be addressed to ensure the software functions correctly. **Adaptive maintenance** involves modifying the software to accommodate changes in the environment, such as new operating systems, hardware, or regulations. This ensures that the software remains compatible with its evolving surroundings. **Perfective maintenance** aims at improving the software's performance, enhancing its features, or adding new functionalities based on user requests or market demands. This type of maintenance helps in keeping the software relevant and valuable over time. **Preventive maintenance** involves making changes to the software to reduce the likelihood of future problems. This might include refactoring code to improve its structure and maintainability or updating documentation. The **software maintenance process** typically involves several steps: **Identification of the need for maintenance**, which can come from bug reports, user feedback, or environmental changes. **Analysis of the request**, to understand the scope and impact of the proposed change. **Design of the modifications**, planning how the changes will be implemented. **Implementation**, making the actual changes to the code and other artifacts. **Testing**, to ensure that the changes are correct and have not introduced new defects. **Deployment**, releasing the modified software to the production environment. And finally, **documentation**, updating all relevant documents to reflect the changes made. Effective software maintenance is crucial for the long-term success of a software system, ensuring its continued operation, relevance, and value.",
        "duration_minutes": 45,
        "keywords": [
          "software maintenance",
          "corrective maintenance",
          "adaptive maintenance",
          "perfective maintenance",
          "preventive maintenance",
          "maintenance process",
          "bug fixing",
          "enhancements",
          "upgrades",
          "refactoring",
          "impact analysis"
        ]
      },
      {
        "lecture_id": 14,
        "week_id": 6,
        "order": 2,
        "title": "**Lecture 14: Software Refactoring and Technical Debt Management**",
        "resource_type": "pdf",
        "resource_url": "https://refactoring.guru/",
        "content_extract": "**Software refactoring is the process of restructuring existing computer code—changing the factoring—without changing its external behavior.** [23] Its purpose is to improve the nonfunctional attributes of the software, such as readability, maintainability, and extensibility. Refactoring is done to make the code easier to understand and modify in the future, thereby reducing the risk of introducing bugs and making maintenance more efficient. Common refactoring techniques include renaming variables and methods to be more descriptive, extracting methods to break down large functions into smaller, more manageable pieces, moving methods and fields to more appropriate classes, and simplifying complex conditional logic. Refactoring should be done incrementally and should be accompanied by thorough testing to ensure that the behavior of the software remains unchanged. **Technical debt**, also known as design debt or code debt, is a metaphor describing the implied cost of additional rework caused by choosing an easy (limited) solution now instead of using a better (more time-consuming) approach [32]. Technical debt can accumulate over time due to factors like tight deadlines, lack of proper design, or inadequate testing. While taking on some technical debt might be necessary in the short term to meet immediate needs, allowing it to accumulate unchecked can lead to increased complexity, lower development velocity, higher maintenance costs, and an increased risk of defects. **Managing technical debt** involves first identifying it through code reviews, static analysis tools, and team discussions. Once identified, technical debt should be prioritized and addressed through refactoring efforts as part of the ongoing development process. Ignoring technical debt can significantly hinder a software project's long-term health and success. Regularly dedicating time and resources to refactoring and reducing technical debt is a crucial aspect of sustainable software development and maintenance.",
        "duration_minutes": 52,
        "keywords": [
          "software refactoring",
          "technical debt",
          "code quality",
          "maintainability",
          "extensibility",
          "refactoring techniques",
          "identifying technical debt",
          "managing technical debt",
          "code reviews",
          "static analysis"
        ]
      },
      {
        "lecture_id": 15,
        "week_id": 7,
        "order": 1,
        "title": "**Lecture 15: Scaling Agile: SAFe and LeSS Frameworks**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=j_jlbS8pS6Y",
        "content_transcript": "Welcome to our lecture on scaling Agile with the SAFe and LeSS frameworks. As Agile practices gain adoption in larger organizations, the need to scale these practices across multiple teams becomes crucial. Scaled Agile Framework (SAFe) and Large-Scale Scrum (LeSS) are two popular frameworks that provide guidance for scaling Agile at the enterprise level. **SAFe** is a comprehensive framework for developing and delivering complex systems. It organizes multiple Agile teams around a value stream, aligning them to a common vision and strategy. SAFe introduces several levels of organization: Team, Program, Large Solution, and Portfolio. Each level has its own set of roles, events, and artifacts, all working together to deliver value incrementally. Key concepts in SAFe include the Agile Release Train (ART), a long-lived team of Agile teams that plans, commits, and executes together; Program Increment (PI) Planning, a cadence-based, face-to-face event that serves as the heartbeat of the ART; and a focus on business value and continuous flow. **LeSS**, on the other hand, is a minimalist framework that builds on standard Scrum principles and aims to scale Scrum 'by keeping it simple'. LeSS provides two frameworks: LeSS for one product group (up to about ten teams) and LeSS Huge for larger product developments. LeSS emphasizes de-scaling organizational structures and focusing on the customer. It promotes a single Product Backlog for the entire product, shared Sprint Planning and Review meetings where appropriate, and the role of Area Product Owners in LeSS Huge. Both SAFe and LeSS address the challenges of coordinating multiple Agile teams, managing dependencies, and ensuring alignment with business objectives, but they do so with different levels of prescription and complexity. Understanding these frameworks is essential for organizations looking to implement Agile at scale.",
        "duration_minutes": 55,
        "keywords": [
          "scaling agile",
          "SAFe",
          "Scaled Agile Framework",
          "LeSS",
          "Large-Scale Scrum",
          "Agile Release Train",
          "ART",
          "Program Increment",
          "PI Planning",
          "Product Backlog",
          "Area Product Owner",
          "value stream",
          "enterprise agility"
        ]
      },
      {
        "lecture_id": 16,
        "week_id": 7,
        "order": 2,
        "title": "**Lecture 16: Kanban and Hybrid Agile Approaches**",
        "resource_type": "pdf",
        "resource_url": "https://leankit.com/learn/kanban/what-is-kanban/",
        "content_extract": "**Kanban is a lean and agile method for managing and improving work across human systems.** [29] Its core principles revolve around visualizing the workflow, limiting work in progress (WIP), managing flow, making process policies explicit, and improving collaboratively. Unlike Scrum, Kanban does not impose time-boxed iterations or specific roles. The primary tool in Kanban is the **Kanban board**, a visual representation of the workflow with columns representing different stages of work and cards representing individual work items. By limiting the number of work items in each stage (WIP limits), Kanban helps teams focus on completing tasks before starting new ones, thereby improving flow and reducing lead time. Kanban is often used in environments with continuous flow of work and evolving priorities. **Hybrid Agile approaches** involve combining elements of different Agile frameworks or blending Agile with traditional project management methodologies like Waterfall [32]. Many organizations adopt hybrid approaches to leverage the benefits of agility while accommodating organizational constraints or specific project needs. For instance, a project might use Scrum for development sprints but follow a more traditional approach for initial requirements gathering or final deployment. Hybrid approaches require careful planning and understanding of the strengths and weaknesses of the different methodologies being combined to ensure effective integration and avoid potential conflicts. Common motivations for adopting a hybrid approach include the need to integrate with existing Waterfall processes, regulatory requirements, or the complexity of large, multi-team projects where a pure Agile approach might be challenging to implement across the entire organization. Successful hybrid approaches often focus on clearly defining the processes and responsibilities at the interfaces between the Agile and traditional components.",
        "duration_minutes": 50,
        "keywords": [
          "kanban",
          "workflow visualization",
          "work in progress",
          "WIP limits",
          "flow management",
          "lead time",
          "continuous flow",
          "hybrid agile",
          "scrum-waterfall hybrid",
          "agile adoption",
          "process integration"
        ]
      },
      {
        "lecture_id": 17,
        "week_id": 8,
        "order": 1,
        "title": "**Lecture 17: Software Engineering Ethics and Professional Responsibility**",
        "resource_type": "youtube",
        "video_url": "https://www.youtube.com/watch?v=4zjYfQlbOyo",
        "content_transcript": "Welcome to our lecture on software engineering ethics and professional responsibility. As software engineers, we have a significant impact on society through the systems we design, develop, and maintain. Therefore, it is crucial to adhere to ethical principles and uphold professional responsibilities. **Software engineering ethics** involves understanding and addressing moral issues related to software development and its impact on individuals, organizations, and society as a whole [5]. This includes considerations such as data privacy, security, reliability, safety, and accessibility. Ethical dilemmas can arise in various situations, such as dealing with confidential user data, ensuring the security of critical systems, or addressing potential biases in algorithms. Professional organizations like the IEEE and ACM have established **codes of ethics** that provide guidelines for software engineers in their professional conduct [12]. These codes typically emphasize principles such as acting in the public interest, maintaining integrity and independence, promoting fairness and equity, acquiring and maintaining professional competence, and respecting the intellectual property of others. **Professional responsibility** entails being accountable for the quality and safety of the software we produce, being transparent about our work, and continuously striving to improve our skills and knowledge. It also involves being aware of and complying with relevant laws and regulations. As software engineers, we have a responsibility to consider the potential consequences of our work and to make ethical decisions that benefit society and minimize harm. This includes being mindful of issues like algorithmic bias, the potential for misuse of technology, and the environmental impact of software systems. Engaging in ethical reflection and adhering to professional standards are essential for building trust in our profession and ensuring that technology is used responsibly.",
        "duration_minutes": 50,
        "keywords": [
          "software engineering ethics",
          "professional responsibility",
          "data privacy",
          "security",
          "reliability",
          "safety",
          "accessibility",
          "algorithmic bias",
          "IEEE Code of Ethics",
          "ACM Code of Ethics",
          "ethical dilemmas",
          "social impact of software"
        ]
      },
      {
        "lecture_id": 18,
        "week_id": 8,
        "order": 2,
        "title": "**Lecture 18: Future Trends in Software Engineering**",
        "resource_type": "pdf",
        "resource_url": "https://www.computer.org/education/bodies-of-knowledge/sebok/v3",
        "content_extract": "**Software engineering is a constantly evolving field, driven by advancements in technology and changing societal needs.** [12] Several key trends are shaping the future of software development. **Artificial Intelligence (AI) and Machine Learning (ML)** are increasingly being integrated into software systems, enabling intelligent automation, predictive analytics, and personalized user experiences [12, 20]. **Cloud Computing** continues to revolutionize how software is deployed and scaled, offering on-demand infrastructure and platform services [12]. **Microservices architecture** is becoming a dominant approach for building scalable and resilient applications by breaking them down into independent, loosely coupled services [12, 23]. **Serverless computing** is gaining popularity, allowing developers to focus on writing code without managing the underlying infrastructure. **DevOps** practices are maturing and expanding, with a greater emphasis on automation, collaboration, and continuous feedback throughout the software lifecycle [12, 23]. **Low-code and no-code platforms** are emerging, enabling individuals with limited programming skills to build applications more easily. **Edge computing** is becoming important for processing data closer to the source, reducing latency for applications like IoT and autonomous vehicles. **Cybersecurity** remains a critical concern, driving advancements in secure coding practices and security tools. **Blockchain technology** is finding applications beyond cryptocurrency, offering secure and transparent ways to manage data and transactions. **Quantum computing**, while still in its early stages, holds the potential to transform certain types of computational problems. Software engineers of the future will need to be adaptable and continuously learn new technologies and paradigms to stay relevant in this dynamic field.",
        "duration_minutes": 48,
        "keywords": [
          "future trends",
          "artificial intelligence",
          "machine learning",
          "cloud computing",
          "microservices",
          "serverless computing",
          "devops",
          "low-code",
          "no-code",
          "edge computing",
          "cybersecurity",
          "blockchain",
          "quantum computing",
          "software evolution"
        ]
      }
    ],
    "questions": [
      {
        "question_id": 3001,
        "content": "Which of the following is NOT a phase in the traditional Waterfall model?",
        "type": "MCQ",
        "question_options": [
          "Requirements",
          "Design",
          "Implementation",
          "Retrospective"
        ],
        "correct_answer": 3,
        "points": 8,
        "explanation": "Retrospective is an Agile practice, not part of the traditional Waterfall model phases. [33]",
        "course_id": 3,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": [
          "SDLC",
          "Waterfall"
        ]
      },
      {
        "question_id": 3002,
        "content": "Which Agile practices emphasize continuous improvement? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Sprint Retrospective",
          "Daily Standup",
          "Backlog Grooming",
          "Pair Programming",
          "Burndown Charts"
        ],
        "correct_answer": [
          0,
          1
        ],
        "points": 10,
        "explanation": "Sprint Retrospectives and Daily Standups focus on continuous improvement through regular reflection and adjustment. [34]",
        "course_id": 3,
        "week_id": 1,
        "lecture_id": 3,
        "status": "active",
        "tags": [
          "Agile",
          "continuous improvement"
        ]
      },
      {
        "question_id": 3003,
        "content": "Calculate the velocity of a team that completed 12 story points in Sprint 1, 15 in Sprint 2, and 13 in Sprint 3.",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 13,
        "points": 8,
        "explanation": "Velocity is calculated as the average of completed story points: (12+15+13)/3 = 13.33 (rounded to 13). [35]",
        "course_id": 3,
        "week_id": 1,
        "lecture_id": 3,
        "status": "active",
        "tags": [
          "Agile",
          "velocity"
        ]
      },
      {
        "question_id": 3004,
        "content": "Which requirement gathering technique is most effective for understanding user workflows?",
        "type": "MCQ",
        "question_options": [
          "Questionnaires",
          "Naturalistic Observation",
          "Document Analysis",
          "Focus Groups"
        ],
        "correct_answer": 1,
        "points": 8,
        "explanation": "Naturalistic Observation allows direct observation of users in their actual work environment. [36]",
        "course_id": 3,
        "week_id": 2,
        "lecture_id": 4,
        "status": "active",
        "tags": [
          "requirements",
          "gathering"
        ]
      },
      {
        "question_id": 3005,
        "content": "What are characteristics of good user stories? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Independent",
          "Negotiable",
          "Valuable",
          "Estimable",
          "Small",
          "Testable"
        ],
        "correct_answer": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "points": 12,
        "explanation": "Good user stories follow the INVEST criteria: Independent, Negotiable, Valuable, Estimable, Small, and Testable. [19]",
        "course_id": 3,
        "week_id": 2,
        "lecture_id": 5,
        "status": "active",
        "tags": [
          "user stories",
          "Agile"
        ]
      },
      {
        "question_id": 3006,
        "content": "How many actors would a typical ATM system use case diagram have?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 2,
        "points": 8,
        "explanation": "A basic ATM system typically has 2 actors: Customer and Bank (or Maintenance Personnel). [37]",
        "course_id": 3,
        "week_id": 2,
        "lecture_id": 5,
        "status": "active",
        "tags": [
          "use cases",
          "UML"
        ]
      },
      {
        "question_id": 3007,
        "content": "Which of the following is an example of a non-functional requirement?",
        "type": "MCQ",
        "question_options": [
          "User can search products by name",
          "System must support 1000 concurrent users",
          "Admin can view sales reports",
          "Customer can add items to cart"
        ],
        "correct_answer": 1,
        "points": 8,
        "explanation": "Supporting concurrent users is a non-functional requirement about system performance. [37]",
        "course_id": 3,
        "week_id": 2,
        "lecture_id": 6,
        "status": "active",
        "tags": [
          "requirements",
          "non-functional"
        ]
      },
      {
        "question_id": 3008,
        "content": "Which SDLC model would be most appropriate for a project with unclear requirements?",
        "type": "MCQ",
        "question_options": [
          "Waterfall",
          "Spiral",
          "Prototype",
          "V-Model"
        ],
        "correct_answer": 2,
        "points": 10,
        "explanation": "Prototype model is ideal when requirements are unclear as it allows for iterative refinement. [38]",
        "course_id": 3,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": [
          "SDLC",
          "models"
        ]
      },
      {
        "question_id": 3009,
        "content": "What percentage of Agile teams typically use Scrum according to recent surveys?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 58,
        "points": 8,
        "explanation": "Recent surveys show approximately 58% of Agile teams use Scrum as their primary methodology. [39]",
        "course_id": 3,
        "week_id": 1,
        "lecture_id": 3,
        "status": "active",
        "tags": [
          "Agile",
          "Scrum"
        ]
      },
      {
        "question_id": 3010,
        "content": "Which elements should be included in a use case description? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Preconditions",
          "Main Flow",
          "Alternative Flows",
          "Postconditions",
          "Exceptions"
        ],
        "correct_answer": [
          0,
          1,
          2,
          3,
          4
        ],
        "points": 12,
        "explanation": "A complete use case description includes all these elements to fully capture the scenario. [18]",
        "course_id": 3,
        "week_id": 2,
        "lecture_id": 5,
        "status": "active",
        "tags": [
          "use cases",
          "requirements"
        ]
      },
      {
        "question_id": 3011,
        "content": "Which architectural pattern separates an application into Model, View, and Controller components?",
        "type": "MCQ",
        "question_options": [
          "MVC",
          "Layered",
          "Microservices",
          "Event-Driven"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "MVC (Model-View-Controller) is the pattern that separates these concerns. [40]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 7,
        "status": "active",
        "tags": [
          "architecture",
          "design patterns"
        ]
      },
      {
        "question_id": 3012,
        "content": "Which design pattern ensures only one instance of a class exists?",
        "type": "MCQ",
        "question_options": [
          "Singleton",
          "Factory",
          "Observer",
          "Decorator"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "The Singleton pattern restricts instantiation to a single object instance. [24]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 8,
        "status": "active",
        "tags": [
          "design patterns",
          "creational"
        ]
      },
      {
        "question_id": 3013,
        "content": "How many relationships are shown in a basic Class Diagram for a simple e-commerce system?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 4,
        "points": 15,
        "explanation": "A basic e-commerce Class Diagram typically shows 4 core relationships: Customer-Order, Order-Product, Product-Category, and Customer-Payment. [24]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 7,
        "status": "active",
        "tags": [
          "UML",
          "class diagram"
        ]
      },
      {
        "question_id": 3014,
        "content": "Which SOLID principle states that a class should have only one reason to change?",
        "type": "MCQ",
        "question_options": [
          "Single Responsibility",
          "Open-Closed",
          "Liskov Substitution",
          "Interface Segregation"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "Single Responsibility Principle (SRP) states that a class should have only one responsibility. [22]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 8,
        "status": "active",
        "tags": [
          "SOLID",
          "OOP"
        ]
      },
      {
        "question_id": 3015,
        "content": "Which testing levels verify interactions between integrated components? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Unit Testing",
          "Integration Testing",
          "System Testing",
          "Acceptance Testing"
        ],
        "correct_answer": [
          1
        ],
        "points": 12,
        "explanation": "Integration Testing specifically focuses on verifying interactions between components. [27]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 9,
        "status": "active",
        "tags": [
          "testing",
          "integration"
        ]
      },
      {
        "question_id": 3016,
        "content": "What is the minimum number of test cases required for 100% branch coverage of a simple if-else statement?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 2,
        "points": 15,
        "explanation": "You need at least 2 test cases: one for the true branch and one for the false branch. [31]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 10,
        "status": "active",
        "tags": [
          "testing",
          "coverage"
        ]
      },
      {
        "question_id": 3017,
        "content": "Which quality attribute measures how easily a system can handle increased workload?",
        "type": "MCQ",
        "question_options": [
          "Reliability",
          "Scalability",
          "Maintainability",
          "Security"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Scalability refers to a system's ability to handle growth in workload. [41]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 9,
        "status": "active",
        "tags": [
          "quality attributes"
        ]
      },
      {
        "question_id": 3018,
        "content": "Which UML diagram best shows object interactions in a specific scenario?",
        "type": "MCQ",
        "question_options": [
          "Class Diagram",
          "Sequence Diagram",
          "Component Diagram",
          "Deployment Diagram"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Sequence Diagrams specifically show object interactions over time. [42]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 7,
        "status": "active",
        "tags": [
          "UML",
          "diagrams"
        ]
      },
      {
        "question_id": 3019,
        "content": "Which patterns are creational design patterns? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Singleton",
          "Adapter",
          "Factory Method",
          "Observer",
          "Builder"
        ],
        "correct_answer": [
          0,
          2,
          4
        ],
        "points": 12,
        "explanation": "Singleton, Factory Method, and Builder are creational patterns. Adapter is structural, and Observer is behavioral. [25]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 8,
        "status": "active",
        "tags": [
          "design patterns",
          "creational"
        ]
      },
      {
        "question_id": 3020,
        "content": "How many test cases are needed for pairwise testing of 3 parameters with 2 values each?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 4,
        "points": 15,
        "explanation": "Pairwise testing for 3 binary parameters requires 4 test cases to cover all pairs. [43]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 10,
        "status": "active",
        "tags": [
          "testing",
          "combinatorial"
        ]
      },
      {
        "question_id": 3021,
        "content": "Which architectural style is most suitable for a highly scalable web application?",
        "type": "MCQ",
        "question_options": [
          "Monolithic",
          "Microservices",
          "Client-Server",
          "Peer-to-Peer"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Microservices architecture provides the best scalability for web applications. [43]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 7,
        "status": "active",
        "tags": [
          "architecture",
          "scalability"
        ]
      },
      {
        "question_id": 3022,
        "content": "Which principles contribute to maintainable code? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Low Coupling",
          "High Cohesion",
          "Code Duplication",
          "Magic Numbers",
          "Clear Naming"
        ],
        "correct_answer": [
          0,
          1,
          4
        ],
        "points": 12,
        "explanation": "Low Coupling, High Cohesion, and Clear Naming all contribute to maintainable code. [26]",
        "course_id": 3,
        "week_id": 3,
        "lecture_id": 8,
        "status": "active",
        "tags": [
          "maintainability",
          "OOP"
        ]
      },
      {
        "question_id": 3023,
        "content": "What percentage of defects are typically found during unit testing according to industry studies?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 25,
        "points": 15,
        "explanation": "Industry studies show about 25% of defects are caught during unit testing. [30]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 9,
        "status": "active",
        "tags": [
          "testing",
          "defects"
        ]
      },
      {
        "question_id": 3024,
        "content": "Which testing technique is most effective for finding security vulnerabilities?",
        "type": "MCQ",
        "question_options": [
          "Unit Testing",
          "Penetration Testing",
          "Regression Testing",
          "Usability Testing"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Penetration Testing specifically targets security vulnerabilities. [28]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 10,
        "status": "active",
        "tags": [
          "testing",
          "security"
        ]
      },
      {
        "question_id": 3025,
        "content": "Which quality attributes are most important for a banking system? Select all that apply.",
        "type": "MSQ",
        "question_options": [
          "Security",
          "Performance",
          "Reliability",
          "Scalability",
          "Modifiability"
        ],
        "correct_answer": [
          0,
          1,
          2
        ],
        "points": 12,
        "explanation": "Security, Performance, and Reliability are critical for banking systems. [44]",
        "course_id": 3,
        "week_id": 4,
        "lecture_id": 9,
        "status": "active",
        "tags": [
          "quality attributes",
          "banking"
        ]
      },
      {
        "question_id": 3026,
        "content": "What is Infrastructure as Code (IaC)?",
        "type": "TEXT",
        "question_options": [],
        "correct_answer": "Managing and provisioning infrastructure through code instead of manual configuration.",
        "points": 10,
        "explanation": "IaC allows for automation, consistency, and version control of infrastructure. [Lecture 11]",
        "course_id": 3,
        "week_id": 5,
        "lecture_id": 11,
        "status": "active",
        "tags": [
          "DevOps",
          "IaC"
        ]
      },
      {
        "question_id": 3027,
        "content": "What are the benefits of a CI/CD pipeline?",
        "type": "MSQ",
        "question_options": [
          "Faster release cycles",
          "Increased risk of bugs in production",
          "Improved code quality",
          "Reduced manual effort",
          "Decreased team collaboration"
        ],
        "correct_answer": [
          0,
          2,
          3
        ],
        "points": 12,
        "explanation": "CI/CD pipelines automate build, test, and deployment processes, leading to faster releases, better quality, and less manual work. [Lecture 12]",
        "course_id": 3,
        "week_id": 5,
        "lecture_id": 12,
        "status": "active",
        "tags": [
          "DevOps",
          "CI/CD"
        ]
      },
      {
        "question_id": 3028,
        "content": "What is the primary goal of corrective software maintenance?",
        "type": "MCQ",
        "question_options": [
          "To adapt software to a new environment",
          "To fix defects found after deployment",
          "To improve software performance",
          "To prevent future problems"
        ],
        "correct_answer": 1,
        "points": 8,
        "explanation": "Corrective maintenance focuses on fixing bugs or errors in the software. [Lecture 13]",
        "course_id": 3,
        "week_id": 6,
        "lecture_id": 13,
        "status": "active",
        "tags": [
          "software maintenance",
          "corrective"
        ]
      },
      {
        "question_id": 3029,
        "content": "Which refactoring technique involves breaking down a large function into smaller, more manageable pieces?",
        "type": "MCQ",
        "question_options": [
          "Rename Method",
          "Extract Method",
          "Move Method",
          "Inline Method"
        ],
        "correct_answer": 1,
        "points": 10,
        "explanation": "Extract Method is used to break down large functions. [Lecture 14]",
        "course_id": 3,
        "week_id": 6,
        "lecture_id": 14,
        "status": "active",
        "tags": [
          "software maintenance",
          "refactoring"
        ]
      },
      {
        "question_id": 3030,
        "content": "What is an Agile Release Train (ART) in the SAFe framework?",
        "type": "TEXT",
        "question_options": [],
        "correct_answer": "A long-lived team of Agile teams that plans, commits, and executes together, aligned to a value stream.",
        "points": 15,
        "explanation": "The ART is a key organizational construct in SAFe. [Lecture 15]",
        "course_id": 3,
        "week_id": 7,
        "lecture_id": 15,
        "status": "active",
        "tags": [
          "Agile",
          "SAFe"
        ]
      },
      {
        "question_id": 3031,
        "content": "What is the purpose of limiting Work in Progress (WIP) in Kanban?",
        "type": "MCQ",
        "question_options": [
          "To increase the number of tasks started",
          "To focus on completing tasks and improving flow",
          "To create bottlenecks in the workflow",
          "To make it harder to identify issues"
        ],
        "correct_answer": 1,
        "points": 10,
        "explanation": "Limiting WIP helps teams focus on finishing tasks and improving the overall flow of work. [Lecture 16]",
        "course_id": 3,
        "week_id": 7,
        "lecture_id": 16,
        "status": "active",
        "tags": [
          "Agile",
          "Kanban"
        ]
      },
      {
        "question_id": 3032,
        "content": "According to the IEEE Code of Ethics, what is a primary responsibility of software engineers?",
        "type": "MCQ",
        "question_options": [
          "Promoting their own interests above all else",
          "Acting consistently with the public interest",
          "Maximizing profits for their employers",
          "Following instructions without question"
        ],
        "correct_answer": 1,
        "points": 12,
        "explanation": "The IEEE Code of Ethics emphasizes acting in a manner consistent with the public interest. [Lecture 17]",
        "course_id": 3,
        "week_id": 8,
        "lecture_id": 17,
        "status": "active",
        "tags": [
          "ethics",
          "professional responsibility"
        ]
      },
      {
        "question_id": 3033,
        "content": "Which emerging trend in software engineering focuses on breaking down applications into small, independent services?",
        "type": "MCQ",
        "question_options": [
          "Cloud Computing",
          "Microservices Architecture",
          "Serverless Computing",
          "Edge Computing"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Microservices architecture involves structuring an application as a collection of small, independent services. [Lecture 18]",
        "course_id": 3,
        "week_id": 8,
        "lecture_id": 18,
        "status": "active",
        "tags": [
          "future trends",
          "architecture"
        ]
      }
    ],
    "assignments": [
      {
        "assignment_id": 3001,
        "week_id": 1,
        "title": "**SDLC and Agile Fundamentals**",
        "description": "Practice questions on software development life cycles and Agile methodologies",
        "type": "practice",
        "due_date": "2025-05-10",
        "start_date": "2025-05-03",
        "is_published": true,
        "question_ids": [
          3001,
          3002,
          3003,
          3008,
          3009,
          3031,
          3025
        ]
      },
      {
        "assignment_id": 3002,
        "week_id": 2,
        "title": "**Requirements Engineering Essentials**",
        "description": "Practice identifying, documenting, and analyzing software requirements using various techniques",
        "type": "practice",
        "due_date": "2025-05-17",
        "start_date": "2025-05-10",
        "is_published": true,
        "question_ids": [
          3004,
          3005,
          3006,
          3007,
          3010,
          3026,
          3027
        ]
      },
      {
        "assignment_id": 3003,
        "week_id": 3,
        "title": "**Software Architecture and Design Principles**",
        "description": "Apply concepts of software architecture styles, design principles (SOLID), and design patterns",
        "type": "graded",
        "due_date": "2025-05-24",
        "start_date": "2025-05-17",
        "is_published": true,
        "question_ids": [
          3011,
          3012,
          3013,
          3014,
          3018,
          3019,
          3021
        ]
      },
      {
        "assignment_id": 3004,
        "week_id": 4,
        "title": "**Software Testing and Quality Assurance Techniques**",
        "description": "Apply knowledge of different testing levels, types, and techniques to ensure software quality",
        "type": "graded",
        "due_date": "2025-05-31",
        "start_date": "2025-05-24",
        "is_published": true,
        "question_ids": [
          3015,
          3016,
          3017,
          3020,
          3023,
          3024,
          3025
        ]
      },
      {
        "assignment_id": 3005,
        "week_id": 5,
        "title": "**Deployment Strategies and DevOps Fundamentals**",
        "description": "Understand software deployment strategies and the principles and practices of DevOps",
        "type": "practice",
        "due_date": "2025-06-07",
        "start_date": "2025-05-31",
        "is_published": true,
        "question_ids": [
          3026,
          3017,
          3028,
          3029,
          3020
        ]
      },
      {
        "assignment_id": 3006,
        "week_id": 6,
        "title": "**Software Maintenance and Technical Debt**",
        "description": "Explore different types of software maintenance and techniques for managing technical debt through refactoring",
        "type": "practice",
        "due_date": "2025-06-14",
        "start_date": "2025-06-07",
        "is_published": true,
        "question_ids": [
          3028,
          3029,
          3021,
          3022,
          3013
        ]
      },
      {
        "assignment_id": 3007,
        "week_id": 7,
        "title": "**Advanced Agile Project Management**",
        "description": "Learn about scaling Agile frameworks (SAFe, LeSS), Kanban, and hybrid agile approaches",
        "type": "graded",
        "due_date": "2025-06-21",
        "start_date": "2025-06-14",
        "is_published": true,
        "question_ids": [
          3030,
          3031,
          3024,
          3015,
          3016
        ]
      },
      {
        "assignment_id": 3008,
        "week_id": 8,
        "title": "**Ethics and Future Trends in Software Engineering**",
        "description": "Consider ethical responsibilities in software engineering and explore emerging trends shaping the field",
        "type": "graded",
        "due_date": "2025-06-28",
        "start_date": "2025-06-21",
        "is_published": true,
        "question_ids": [
          3032,
          3033,
          3017,
          3028,
          3019
        ]
      }
    ],
    "personal_resources": [
      {
        "resource_id": 1,
        "name": "SE Process Notes",
        "description": "**Extensive personal notes covering a range of software development models, their methodologies, strengths, limitations, and real-world applications.** [45]",
        "course_id": 3,
        "user_id": 2001,
        "is_active": true,
        "LLM_Summary": {
          "summary": "**In-depth notes on software development processes, detailing the phases, characteristics, and comparative analysis of key SDLC models, including real-world applicability and practical implications.** [45]",
          "concepts_covered": [
            "**Waterfall model phases and their sequential nature** [46]",
            "**Prototype model benefits with iterative refinement and risk mitigation** [46]",
            "**Spiral model characteristics combining iterative development with risk analysis** [46]",
            "**Agile principles emphasizing flexibility, collaboration, and incremental delivery** [46]",
            "**Testing methodologies: Unit, Integration, System, and User Acceptance Testing** [46]",
            "**Requirement gathering and documentation best practices** [46]",
            "**Maintenance phases: corrective, adaptive, perfective, and preventive maintenance** [46]",
            "Comparison of different Agile frameworks (Scrum, Kanban)",
            "Overview of software architecture styles",
            "Key software design principles"
          ],
          "concepts_not_covered": [
            "In-depth tool-specific implementation (e.g., JIRA, Git workflows) [47]",
            "Industry-specific case studies and real-world project comparisons [47]",
            "Scalability concerns in large-scale software development [47]",
            "Advanced SDLC hybrid models (e.g., DevOps and Scrumban) [47]",
            "Detailed discussion on software testing techniques",
            "Specifics of deployment strategies and DevOps tools",
            "Advanced topics in software maintenance and refactoring",
            "Enterprise-level Agile scaling frameworks in detail"
          ]
        }
      }
    ],
    "personal_resource_files": [
      {
        "file_id": 1,
        "resource_id": 1,
        "name": "Week 1-2 Notes",
        "type": "text",
        "content": "# Software Engineering Notes\n\n## Development Models\n- **Waterfall Model**: Sequential phases (Requirements → Design → Implementation → Testing → Maintenance). Suitable for well-defined requirements, but inflexible to changes.\n- **Prototype Model**: Develop prototype → Gather feedback → Refine. Useful for unclear requirements and early user involvement.\n- **Spiral Model**: Iterative with risk analysis (Planning → Risk Analysis → Engineering → Evaluation). Good for complex, high-risk projects.\n- **Agile Model**: Iterative and incremental, emphasizing customer collaboration and response to change. Includes frameworks like Scrum and Kanban.\n- **V-Model**: Extension of Waterfall, emphasizes testing at each development stage (Verification and Validation).\n- **Incremental Model**: Builds the system in small, functional increments.\n\n## Requirements Engineering\n- **Elicitation Techniques**: Interviews, questionnaires, observation, focus groups, document analysis.\n- **Requirement Types**: Functional (what the system should do) vs. Non-Functional (how the system should perform - e.g., performance, security, usability).\n- **Documentation**: Use Cases (actor-system interactions), User Stories (user-centric, used in Agile), SRS (Software Requirements Specification).\n- **Prioritization**: MoSCoW (Must have, Should have, Could have, Won't have), Kano model.\n- **Validation and Verification**: Ensuring requirements are correct and meet stakeholder needs.\n- **Traceability**: Linking requirements to design, code, and tests.",
        "file_type": "text/markdown",
        "file_size": 6144
      },
      {
        "file_id": 2,
        "resource_id": 1,
        "name": "Requirement Templates",
        "type": "file",
        "content": "A curated collection of templates for documenting various software requirements, including:\n\n1. Functional and Non-Functional Requirements\n2. User Stories with Acceptance Criteria\n3. Software Requirement Specification (SRS) Outline\n4. Traceability Matrix\n\nEach template is designed to ensure comprehensive coverage and facilitate effective communication between stakeholders and development teams.",
        "file_path": "/uploads/user2001/se101/req_templates.docx",
        "file_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "file_size": 8192
      },
      {
        "file_id": 3,
        "resource_id": 1,
        "name": "Testing Methodologies Overview",
        "type": "text",
        "content": "# Software Testing Methodologies\n\n## 1. Unit Testing\n- **Purpose**: Validate individual components or functions\n- **Techniques**: Test-driven development (TDD)\n\n## 2. Integration Testing\n- **Purpose**: Ensure proper interaction between integrated components\n- **Types**: Top-down, bottom-up, sandwich testing\n\n## 3. System Testing\n- **Purpose**: Validate the complete and integrated system\n- **Types**: Functional, non-functional (performance, security, usability, reliability)\n\n## 4. User Acceptance Testing (UAT)\n- **Purpose**: Verify system compliance with user requirements\n- **Outcome**: Approve software for deployment\n\n## Key Concepts\n- **Black-box testing**: Testing without knowledge of internal code.\n- **White-box testing**: Testing based on internal code structure.\n- **Test Coverage**: Statement, branch, path coverage.",
        "file_type": "text/markdown",
        "file_size": 5120
      }
    ]
  }