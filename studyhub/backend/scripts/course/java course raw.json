{
  "course": {
    "course_id": 2,
    "code": "JAVA101",
    "title": "Introduction to Java Programming",
    "description": "A foundational course in Java programming principles.",
    "instructor_id": 201,
    "credits": 3,
    "department": "Computer Science",
    "image_url": "/assets/courses/java101/cover.jpg",
    "prerequisites": ["None"],
    "learning_outcomes": ["Understand basic Java syntax", "Develop object-oriented programming skills in Java", "Handle exceptions and collections in Java"],
    "assessment_methods": ["Quizzes", "Assignments", "Midterm Exam", "Final Exam"],
    "delivery_mode": "Online",
    "tools_and_technologies": ["JDK", "Eclipse", "IntelliJ IDEA"],
    "LLM_Summary": {
      "summary": "Introduction to Java programming syntax, object-oriented concepts, exception handling, and collections.",
      "concepts_covered": ["Java basics", "Object-oriented programming", "Exception handling", "Collections"],
      "concepts_not_covered": ["Advanced Java frameworks", "Concurrency in depth"]
    },
    "acronyms": {
      "JDK": "Java Development Kit",
      "JVM": "Java Virtual Machine",
      "WORA": "Write Once, Run Anywhere",
      "IDE": "Integrated Development Environment",
      "Java SE": "Java Standard Edition",
      "Java EE": "Java Enterprise Edition",
      "Java ME": "Java Micro Edition"
    }
    ,
    "synonyms": {
      "Object-Oriented Programming": ["OOP", "Object-Oriented Design"],
      "Inheritance": ["Subclassing", "Extension of Classes"],
      "Exception Handling": ["Runtime Error Handling"],
      "Polymorphism": ["Method Overriding", "Dynamic Binding"]
    }
    
  },
  "weeks": [
    {
      "week_id": 3,
      "course_id": 2,
      "order": 1,
      "title": "Week 1: Introduction to Java and Setup",
      "estimated_hours": 10,
      "LLM_Summary": {
        "summary": "Introduction to Java programming language and setting up the development environment.",
        "concepts_covered": ["Java history", "JDK installation", "Basic syntax"],
        "concepts_not_covered": ["Advanced data types"]
      }
    },
    {
      "week_id": 4,
      "course_id": 2,
      "order": 2,
      "title": "Week 2: Data Types, Variables, and Operators",
      "estimated_hours": 12,
      "LLM_Summary": {
        "summary": "Understanding primitive data types, variables, and operators in Java.",
        "concepts_covered": ["Primitive types", "Variable declaration", "Arithmetic operators", "Comparison operators"],
        "concepts_not_covered": ["Bitwise operators in detail"]
      }
    },
    {
      "week_id": 5,
      "course_id": 2,
      "order": 3,
      "title": "Week 3: Control Flow Statements",
      "estimated_hours": 12,
      "LLM_Summary": {
        "summary": "Learning about decision-making and looping constructs in Java.",
        "concepts_covered": ["If-else statements", "Switch statements", "For loops", "While loops", "Do-while loops"],
        "concepts_not_covered": ["Advanced loop control techniques"]
      }
    },
    {
      "week_id": 6,
      "course_id": 2,
      "order": 4,
      "title": "Week 4: Introduction to Classes and Objects",
      "estimated_hours": 15,
      "LLM_Summary": {
        "summary": "Introduction to the fundamental concepts of object-oriented programming: classes and objects.",
        "concepts_covered": ["Class definition", "Object creation", "Instance variables", "Methods"],
        "concepts_not_covered": ["Static members in depth"]
      }
    },
    {
      "week_id": 7,
      "course_id": 2,
      "order": 5,
      "title": "Week 5: Constructors and Access Modifiers",
      "estimated_hours": 13,
      "LLM_Summary": {
        "summary": "Understanding constructors for object initialization and access modifiers for controlling visibility.",
        "concepts_covered": ["Constructors", "Default constructor", "Parameterized constructor", "Public, private, protected, default access"],
        "concepts_not_covered": ["Inner classes and access modifiers"]
      }
    },
    {
      "week_id": 8,
      "course_id": 2,
      "order": 6,
      "title": "Week 6: Inheritance",
      "estimated_hours": 15,
      "LLM_Summary": {
        "summary": "Exploring inheritance as a key concept in object-oriented programming.",
        "concepts_covered": ["Superclass and subclass", "Extends keyword", "Method overriding", "Super keyword"],
        "concepts_not_covered": ["Multiple inheritance in Java"]
      }
    },
    {
      "week_id": 9,
      "course_id": 2,
      "order": 7,
      "title": "Week 7: Polymorphism and Abstract Classes",
      "estimated_hours": 14,
      "LLM_Summary": {
        "summary": "Understanding polymorphism and the use of abstract classes and methods.",
        "concepts_covered": ["Polymorphism", "Upcasting and downcasting", "Abstract classes", "Abstract methods"],
        "concepts_not_covered": ["Interfaces in detail"]
      }
    },
    {
      "week_id": 10,
      "course_id": 2,
      "order": 8,
      "title": "Week 8: Exception Handling",
      "estimated_hours": 12,
      "LLM_Summary": {
        "summary": "Learning how to handle runtime errors using exceptions in Java.",
        "concepts_covered": ["Try-catch blocks", "Finally block", "Throwing exceptions", "Built-in exception hierarchy"],
        "concepts_not_covered": ["Custom exception creation in depth"]
      }
    },
    {
      "week_id": 11,
      "course_id": 2,
      "order": 9,
      "title": "Week 9: Introduction to Collections",
      "estimated_hours": 13,
      "LLM_Summary": {
        "summary": "Introduction to Java collections framework and basic collection types.",
        "concepts_covered": ["ArrayList", "LinkedList", "HashSet", "Basic operations"],
        "concepts_not_covered": ["Maps and advanced collection operations"]
      }
    }
  ],
  "lectures": [
    {
      "lecture_id": 3,
      "week_id": 3,
      "order": 1,
      "title": "Introduction to Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_intro.mp4",
      "content_transcript": "Welcome to the world of Java programming! In this lecture, we'll embark on a journey to understand what Java is, its history, and why it's such a popular language. Java, initially named Oak by James Gosling at Sun Microsystems in 1991, was later renamed Java in 1995. It was designed with the principle of 'Write Once, Run Anywhere' (WORA), meaning that code written on one platform can run on any other platform that has a Java Virtual Machine (JVM). This platform independence is one of the key reasons for Java's widespread adoption. We'll also discuss the different editions of Java, including Java Standard Edition (SE), Java Enterprise Edition (EE), and Java Micro Edition (ME), though we'll primarily focus on Java SE in this course. Understanding the architecture of Java, particularly the role of the JVM and bytecode, is crucial. When you compile a Java source file (.java), it's translated into bytecode (.class), which is then executed by the JVM. The JVM provides an abstraction layer between the compiled code and the underlying operating system, enabling portability. We'll briefly touch upon the basic syntax of a Java program. A simple 'Hello, World!' program in Java looks like this: `public class HelloWorld { public static void main(String[] args) { System.out.println('Hello, World!'); } }` We'll break down this code, explaining the keywords like `public`, `class`, `static`, `void`, `main`, `String[] args`, and `System.out.println()`. We'll also discuss the importance of semicolons in Java and the concept of case sensitivity. Finally, we'll guide you through the process of downloading and installing the Java Development Kit (JDK), which includes the compiler (`javac`) and the JVM (`java`), essential tools for Java development. We'll also briefly introduce Integrated Development Environments (IDEs) like Eclipse and IntelliJ IDEA, which can greatly enhance your coding experience, though we'll start with command-line compilation for better understanding. Make sure you have your development environment set up before the next lecture! Remember, the key to mastering Java, like any programming language, is practice. Don't hesitate to experiment with the code examples and try writing your own simple programs. Your first task will be to successfully compile and run the 'Hello, World!' program on your system. This foundational step is crucial for everything that follows. We'll also touch upon the importance of comments in Java code for improving readability and maintainability. Java supports both single-line comments (starting with `//`) and multi-line comments (enclosed between `/*` and `*/`). Using comments effectively is a good practice to adopt early in your programming journey. We'll also briefly discuss naming conventions in Java for classes, methods, and variables. Following consistent and meaningful naming conventions makes your code easier to understand. For example, class names typically start with an uppercase letter and follow CamelCase, while method and variable names usually start with a lowercase letter. This lecture sets the stage for our exploration of Java. Make sure to review the concepts and complete the setup to be well-prepared for the upcoming topics. We'll be building upon these fundamentals in the subsequent weeks, delving into data types, operators, control flow, and eventually object-oriented programming. Welcome aboard!",
      "duration_minutes": 45,
      "keywords": ["Java", "Introduction", "History", "JVM", "Setup", "HelloWorld", "Syntax"]
    },
    {
      "lecture_id": 4,
      "week_id": 3,
      "order": 2,
      "title": "Setting up the Java Development Environment",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week1_Lecture2.pdf",
      "content_extract": "This lecture provides a step-by-step guide to setting up your Java development environment. The first crucial step is downloading the Java Development Kit (JDK) from Oracle's official website or an alternative open-source distribution like OpenJDK. Ensure you select the appropriate version for your operating system (Windows, macOS, Linux). The installation process involves running the downloaded installer and following the on-screen instructions. Pay attention to the installation directory, as you might need this information later. After installation, it's essential to configure your system's environment variables. For Windows, this typically involves adding the `bin` directory of your JDK installation to the `Path` environment variable. This allows you to execute Java commands like `javac` and `java` from any command prompt window. On macOS and Linux, you might need to set the `JAVA_HOME` environment variable and update your `PATH`. Detailed instructions for each operating system will be provided. Once the environment variables are configured, you should verify the installation by opening a command prompt or terminal and running the command `java -version` and `javac -version`. If the JDK is installed correctly, these commands will display the installed Java version and compiler version, respectively. Next, we'll introduce Integrated Development Environments (IDEs). While you can write and compile Java code using a simple text editor and the command line, IDEs offer a more feature-rich environment that can significantly improve your productivity. Popular Java IDEs include Eclipse, IntelliJ IDEA, and NetBeans. We'll briefly discuss the advantages of using an IDE, such as code completion, syntax highlighting, debugging tools, and project management features. You are encouraged to choose an IDE that you feel comfortable with. We'll provide links to the official download pages for these IDEs. For the purpose of this course, you can start with command-line compilation to gain a better understanding of the underlying processes. However, as you progress, using an IDE will become increasingly beneficial for managing larger projects. This lecture will also cover basic project setup in an IDE. Typically, you'll create a new Java project, which will organize your source files and other project-related resources. We'll demonstrate how to create a simple project and add a new Java class to it. Remember to save your Java source files with the `.java` extension. Finally, we'll reiterate the importance of testing your setup by creating and running a simple 'Hello, World!' program within your chosen environment, whether it's the command line or an IDE. If you encounter any issues during the setup process, please refer to the troubleshooting guide provided or seek help on the course forums. A properly configured development environment is the foundation for your Java programming journey. Make sure to complete all the steps outlined in this lecture before moving on to the next topic.",
      "duration_minutes": 60,
      "keywords": ["Java", "Setup", "JDK", "Installation", "Environment Variables", "IDE", "Eclipse"]
    },
    {
      "lecture_id": 5,
      "week_id": 4,
      "order": 1,
      "title": "Primitive Data Types and Variables in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_datatypes.mp4",
      "content_transcript": "Welcome back! In this lecture, we'll dive into the fundamental building blocks of data storage in Java: primitive data types and variables. Java is a statically-typed language, which means that the type of a variable must be declared before it can be used, and this type cannot be changed later. Java provides eight primitive data types: `byte`, `short`, `int`, `long` for whole numbers; `float` and `double` for floating-point numbers; `boolean` for true/false values; and `char` for single characters. We'll discuss each of these types in detail, including their size in memory and the range of values they can hold. For example, a `byte` is an 8-bit signed integer, while an `int` is a 32-bit signed integer. Understanding these ranges is important to avoid overflow or underflow issues in your programs. We'll look at examples of declaring variables of each primitive type and assigning values to them. The syntax for declaring a variable in Java is `dataType variableName;` or `dataType variableName = value;`. For instance: `int age = 30;`, `double price = 19.99;`, `boolean isTrue = true;`, `char initial = 'J';`. We'll emphasize the importance of choosing the appropriate data type for the kind of data you need to store. Using a `double` for a variable that will always hold whole numbers is inefficient in terms of memory usage. We'll also discuss the concept of literals, which are the constant values assigned to variables. For example, `30` is an integer literal, `19.99` is a double literal, `true` and `false` are boolean literals, and `'J'` is a character literal. We'll touch upon integer literals in different bases (decimal, binary, hexadecimal) and floating-point literals with and without exponents. Furthermore, we'll cover variable naming conventions in Java. While Java allows almost any sequence of letters, digits, underscores, and dollar signs for variable names, it's a good practice to follow certain conventions to make your code more readable. Variable names should be descriptive and should typically start with a lowercase letter. For multi-word variable names, we usually use camelCase (e.g., `numberOfStudents`). We'll also discuss the difference between declaration and initialization of variables. Declaring a variable simply reserves space in memory for a value of a specific type, while initialization assigns an initial value to that memory location. It's often a good practice to initialize variables when they are declared. Finally, we'll briefly introduce the concept of type conversion or casting in Java. Sometimes, you might need to convert a value of one data type to another. Java supports both implicit (widening) and explicit (narrowing) type conversions. We'll look at examples of when each type of conversion is possible and when you need to use a cast operator. For example, an `int` can be implicitly converted to a `double`, but converting a `double` to an `int` requires an explicit cast. Understanding primitive data types and variables is fundamental to writing any Java program. Make sure you grasp these concepts well before moving on to the next lecture on operators.",
      "duration_minutes": 50,
      "keywords": ["Java", "Data Types", "Primitive Types", "Variables", "Declaration", "Initialization", "Literals"]
    },
    {
      "lecture_id": 6,
      "week_id": 4,
      "order": 2,
      "title": "Operators in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week2_Lecture2.pdf",
      "content_extract": "In this lecture, we will explore the various operators available in Java. Operators are special symbols that perform operations on operands (variables and values). Java provides several categories of operators: arithmetic operators, assignment operators, comparison operators, logical operators, and more. We'll start with arithmetic operators, which are used to perform mathematical calculations. These include addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and modulus (`%`). We'll look at examples of how to use these operators with different numeric data types. It's important to note the behavior of division, especially integer division, where the fractional part of the result is truncated. The modulus operator (%) gives the remainder of a division. Next, we'll cover assignment operators, which are used to assign values to variables. The most basic assignment operator is the equals sign (`=`). Java also provides compound assignment operators, such as `+=`, `-=`, `*=`, `/=`, and `%=`, which combine an arithmetic operation with assignment. For example, `x += 5` is equivalent to `x = x + 5`. These operators provide a concise way to modify the value of a variable. Comparison operators are used to compare two values and return a boolean result (`true` or `false`). These include equal to (`==`), not equal to (`!=`), greater than (`>`), less than (`<`), greater than or equal to (`>=`), and less than or equal to (`<=`). Comparison operators are often used in control flow statements to make decisions based on conditions. Logical operators are used to combine or modify boolean expressions. The main logical operators in Java are logical AND (`&&`), logical OR (`||`), and logical NOT (`!`). We'll explain the truth tables for these operators and how they are used to create more complex conditions. It's crucial to understand the short-circuiting behavior of `&&` and `||`. We'll also briefly touch upon other operators like increment (`++`) and decrement (`--`) operators (both prefix and postfix), and the ternary operator (`?:`), which provides a concise way to express simple conditional assignments. Operator precedence is an important concept to understand, as it determines the order in which operations are performed in an expression. Java follows a specific order of precedence. For example, multiplication and division have higher precedence than addition and subtraction. Parentheses can be used to override the default precedence. We'll provide a table summarizing the precedence of common Java operators. Understanding operators is essential for performing calculations, making comparisons, and controlling the flow of execution in your Java programs. We'll work through several examples to illustrate the usage of different operators and their precedence. Pay close attention to the nuances of each operator, as they form the basis of many programming tasks.",
      "duration_minutes": 55,
      "keywords": ["Java", "Operators", "Arithmetic Operators", "Assignment Operators", "Comparison Operators", "Logical Operators", "Precedence"]
    },
    {
      "lecture_id": 7,
      "week_id": 5,
      "order": 1,
      "title": "If-Else and Switch Statements in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_conditionals.mp4",
      "content_transcript": "Welcome to this lecture on control flow in Java! Today, we'll focus on decision-making statements: `if-else` and `switch`. These statements allow your program to execute different blocks of code based on certain conditions. The `if` statement is the most basic conditional statement. It allows you to execute a block of code only if a specified condition is true. The syntax of a simple `if` statement is: `if (condition) { // code to be executed if the condition is true }`. The condition is a boolean expression that evaluates to either `true` or `false`. We'll look at examples of using `if` statements with different types of conditions. The `if-else` statement extends the `if` statement by providing a block of code to be executed if the condition is false. The syntax is: `if (condition) { // code to be executed if the condition is true } else { // code to be executed if the condition is false }`. We'll demonstrate scenarios where using an `if-else` statement is appropriate. You can also chain multiple `if-else` statements together using `else if` to test multiple conditions in sequence. The syntax is: `if (condition1) { // code for condition1 } else if (condition2) { // code for condition2 } else { // code for none of the above conditions }`. It's important to note that once a condition is found to be true, the corresponding block of code is executed, and the rest of the `else if` and `else` blocks are skipped. We'll discuss best practices for using `if-else` statements, such as keeping the conditions clear and the code blocks concise. The `switch` statement provides another way to execute different blocks of code based on the value of an expression. However, the `switch` statement can only test for equality against a set of constant values. The syntax of a `switch` statement is: `switch (expression) { case value1: // code to be executed if expression equals value1 break; case value2: // code to be executed if expression equals value2 break; default: // code to be executed if expression doesn't match any of the cases }`. The `break` statement is crucial; it terminates the `switch` statement after a matching `case` is found. If `break` is omitted, execution will 'fall through' to the next `case`. The `default` case is optional and specifies the code to be executed if none of the `case` values match the expression. We'll look at examples of using `switch` statements with different data types (integers, characters, enums, and strings in newer Java versions). We'll also discuss the advantages and disadvantages of using `if-else` versus `switch` statements. `If-else` is more versatile as it can test complex conditions, while `switch` is often more readable when you need to compare a single variable against multiple constant values. Understanding how to use these conditional statements effectively is essential for creating programs that can make decisions and respond to different inputs or situations. We'll work through various examples to solidify your understanding. Remember to pay attention to the syntax and the logic of each type of statement.",
      "duration_minutes": 50,
      "keywords": ["Java", "Control Flow", "If Statement", "Else Statement", "Else If", "Switch Statement", "Case", "Break", "Default"]
    },
    {
      "lecture_id": 8,
      "week_id": 5,
      "order": 2,
      "title": "Loops in Java: For, While, and Do-While",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week3_Lecture2.pdf",
      "content_extract": "In this lecture, we will learn about the different types of loops available in Java: `for`, `while`, and `do-while`. Loops are used to repeatedly execute a block of code as long as a certain condition is true. The `for` loop is often used when you know in advance how many times you need to execute a block of code. It consists of three parts within the parentheses: initialization, condition, and increment/decrement. The syntax of a `for` loop is: `for (initialization; condition; increment/decrement) { // code to be executed }`. The initialization part is executed only once at the beginning of the loop. The condition is evaluated before each iteration; if it's true, the loop body is executed. The increment/decrement part is executed after each iteration. We'll look at various examples of `for` loops, including iterating a specific number of times, iterating over arrays (which we'll learn about later), and using nested `for` loops. The `while` loop is used when you don't know in advance how many times you need to execute a block of code; the loop continues as long as the specified condition is true. The syntax of a `while` loop is: `while (condition) { // code to be executed }`. It's crucial to ensure that the condition eventually becomes false, otherwise the loop will run indefinitely (infinite loop). We'll discuss common scenarios where `while` loops are used. The `do-while` loop is similar to the `while` loop, but with one important difference: the loop body is executed at least once before the condition is checked. The syntax of a `do-while` loop is: `do { // code to be executed } while (condition);`. The semicolon at the end is important. `Do-while` loops are useful when you want to execute a block of code and then decide whether to repeat based on a condition. We'll compare and contrast the `for`, `while`, and `do-while` loops and discuss when it's most appropriate to use each type. We'll also cover the `break` and `continue` statements, which can be used to control the flow of execution within a loop. The `break` statement immediately exits the loop, while the `continue` statement skips the rest of the current iteration and proceeds to the next iteration. Understanding loops is fundamental to automating repetitive tasks in programming. We'll work through several examples, including calculating sums, processing sequences, and implementing basic algorithms using loops. Pay attention to the initialization, condition, and update parts of each loop to ensure they behave as expected and avoid infinite loops. Practice writing different types of loops to solidify your understanding.",
      "duration_minutes": 60,
      "keywords": ["Java", "Control Flow", "Loops", "For Loop", "While Loop", "Do-While Loop", "Break", "Continue"]
    },
    {
      "lecture_id": 9,
      "week_id": 6,
      "order": 1,
      "title": "Introduction to Classes in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_classes.mp4",
      "content_transcript": "Welcome to the exciting world of Object-Oriented Programming (OOP) in Java! In this lecture, we'll start with the fundamental concept of a class. A class is a blueprint or a template for creating objects. It defines the structure and behavior of objects of that class. Think of it as a cookie cutter that defines the shape and properties of cookies. A class contains data, known as attributes or instance variables, and methods, which define the actions or behaviors that objects of the class can perform. The syntax for defining a class in Java starts with the `class` keyword, followed by the name of the class (which should follow PascalCase convention, starting with an uppercase letter), and the class body enclosed in curly braces `{}`. For example: `public class Dog { // attributes (instance variables) String breed; String name; int age; // methods void bark() { System.out.println('Woof!'); } }` In this example, `Dog` is the class name, `breed`, `name`, and `age` are the attributes, and `bark()` is a method. We'll discuss the different types of members that a class can contain, including instance variables, methods, constructors (which we'll cover in the next lecture), and static members (which we'll discuss later). Instance variables define the state of an object, while methods define its behavior. The access modifiers (`public`, `private`, `protected`, default) control the visibility of class members. We'll touch upon the `public` access modifier, which means the member is accessible from anywhere. We'll delve deeper into access modifiers in a later lecture. Inside a method, you can write code to perform specific tasks. Methods can have parameters (inputs) and can return a value. The structure of a method includes an access modifier, a return type (or `void` if it doesn't return a value), the method name (following camelCase convention), a list of parameters in parentheses, and the method body enclosed in curly braces. We'll look at examples of methods with and without parameters and with and without return values. It's important to understand the difference between a class and an object. A class is the blueprint, while an object is an instance of the class. You can create multiple objects from a single class. Each object will have its own set of instance variables, and they can all use the methods defined in the class. To create an object of a class, you use the `new` keyword followed by the class name and parentheses (which might contain arguments for the constructor). For example: `Dog myDog = new Dog();`. Here, `myDog` is an object (an instance) of the `Dog` class. We'll demonstrate how to create objects and access their attributes and methods using the dot operator (`.`). Understanding classes is the foundation of object-oriented programming in Java. In the following lectures, we'll build upon this knowledge by exploring concepts like constructors, access modifiers, inheritance, and polymorphism. Make sure you understand the basic syntax of defining a class and creating objects before proceeding.",
      "duration_minutes": 55,
      "keywords": ["Java", "OOP", "Classes", "Attributes", "Instance Variables", "Methods", "Object Creation"]
    },
    {
      "lecture_id": 10,
      "week_id": 6,
      "order": 2,
      "title": "Creating and Using Objects in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week4_Lecture2.pdf",
      "content_extract": "In the previous lecture, we introduced the concept of classes in Java. Now, we'll focus on how to create and use objects, which are instances of these classes. Creating an object is also known as instantiation. To create an object of a class, you use the `new` keyword followed by a call to the class's constructor. The constructor is a special method that initializes the object. We'll delve into constructors in the next lecture, but for now, you can think of `ClassName()` as the default way to create an object if no specific constructor is defined. For example, if we have a class named `Car`, we can create an object of this class using the following statement: `Car myCar = new Car();`. Here, `myCar` is a reference variable that holds a reference to the newly created `Car` object in memory. It's important to understand that `myCar` itself is not the object, but rather a pointer to the object. You can declare multiple reference variables that refer to the same object. Once you have an object, you can access its attributes (instance variables) and invoke its methods using the dot operator (`.`). The syntax for accessing an attribute is `objectName.attributeName`, and the syntax for invoking a method is `objectName.methodName(arguments)`. For example, if our `Car` class has an attribute `color` and a method `startEngine()`, we can access them like this: `myCar.color = 'Red';` and `myCar.startEngine();`. We'll demonstrate this with various examples, showing how to set the values of attributes and call methods on different objects. Each object of a class has its own set of instance variables. So, if you create another `Car` object, say `yourCar`, its `color` attribute can be different from `myCar.color`. Objects interact with each other through their methods. One object can call a method of another object, passing data as arguments if needed. This interaction between objects is a key aspect of object-oriented programming. We'll illustrate this with scenarios where objects of different classes interact. For example, a `Driver` object might interact with a `Car` object by calling its `startEngine()` and `accelerate()` methods. Understanding object references is crucial. When you assign one object reference variable to another, you are essentially making both variables refer to the same object in memory. You are not creating a new object. This means that if you modify an attribute of the object through one reference, the change will be visible through the other reference as well. We'll demonstrate this concept with examples. The lifetime of an object in Java is managed by the Java Virtual Machine's garbage collector. An object remains in memory as long as there is at least one active reference pointing to it. When an object is no longer referenced by any variable, it becomes eligible for garbage collection, and its memory can be reclaimed by the JVM. You don't need to explicitly free memory in Java as you might in some other programming languages. In this lecture, we've covered the basics of creating objects from classes and interacting with them by accessing their attributes and invoking their methods. We've also touched upon the concept of object references and the role of the garbage collector. In the next lecture, we'll delve deeper into constructors, which play a vital role in object initialization.",
      "duration_minutes": 65,
      "keywords": ["Java", "OOP", "Objects", "Instantiation", "Reference Variables", "Accessing Attributes", "Invoking Methods", "Garbage Collection"]
    },
    {
      "lecture_id": 11,
      "week_id": 7,
      "order": 1,
      "title": "Constructors in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_constructors.mp4",
      "content_transcript": "Welcome to this lecture on constructors in Java! A constructor is a special method that is called automatically when an object of a class is created. Its primary purpose is to initialize the object's state, i.e., to set the initial values of its instance variables. Constructors have the same name as the class and do not have a return type (not even `void`). Java provides a default constructor if you don't define any constructors in your class. The default constructor is a no-argument constructor that initializes all instance variables to their default values (e.g., 0 for numeric types, `false` for boolean, `null` for object references). However, once you define one or more constructors in your class, the default constructor is no longer automatically provided. You can define your own constructors to provide custom initialization logic. A constructor can have parameters, allowing you to pass initial values for the object's attributes when you create it. These are known as parameterized constructors. For example, if we have a `Rectangle` class with `width` and `height` attributes, we can define a parameterized constructor like this: `public class Rectangle { int width; int height; public Rectangle(int w, int h) { width = w; height = h; } // ... }` When you create a `Rectangle` object using this constructor, you need to provide the initial width and height: `Rectangle rect = new Rectangle(10, 20);`. Constructors can be overloaded, meaning you can have multiple constructors in the same class with different parameter lists (different number or types of parameters). The appropriate constructor to call is determined by the arguments you provide when creating the object. Constructor overloading allows you to create objects with different initial states. Within a constructor, you can also call another constructor of the same class using the `this()` keyword. This is often used to avoid code duplication when you have multiple constructors with overlapping initialization logic. The call to `this()` must be the first statement in the constructor. For example: `public class Employee { int id; String name; public Employee(int i) { id = i; } public Employee(int i, String n) { this(i); name = n; } // ... }` In this case, the second constructor calls the first one to initialize the `id`. Constructors can also call constructors of the superclass using the `super()` keyword. This is relevant when dealing with inheritance, which we'll discuss in a later lecture. The call to `super()` must also be the first statement in the constructor. It's important to understand the role of constructors in ensuring that objects are properly initialized before they are used. By defining appropriate constructors, you can enforce certain initial conditions for your objects and make your code more robust. We'll look at several examples of classes with different types of constructors, including no-argument constructors, parameterized constructors, and constructors that call other constructors using `this()`. Understanding constructors is crucial for effective object-oriented programming in Java. Make sure you grasp how to define and use constructors to initialize your objects correctly.",
      "duration_minutes": 60,
      "keywords": ["Java", "OOP", "Constructors", "Default Constructor", "Parameterized Constructor", "Constructor Overloading", "This Keyword", "Initialization"]
    },
    {
      "lecture_id": 12,
      "week_id": 7,
      "order": 2,
      "title": "Access Modifiers in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week5_Lecture2.pdf",
      "content_extract": "In this lecture, we will discuss access modifiers in Java, which control the visibility and accessibility of classes, interfaces, variables, methods, and constructors. Java provides four access modifiers: `public`, `private`, `protected`, and default (also known as package-private). The `public` access modifier means that the member is accessible from any class, in any package. When you declare a class or a member as `public`, it has the widest scope of accessibility. The `private` access modifier means that the member is accessible only within the class in which it is declared. No other class, not even subclasses or classes in the same package, can directly access `private` members. `Private` access is often used for data hiding and encapsulation, which are key principles of object-oriented programming. The `protected` access modifier means that the member is accessible within its own class, within its subclass (in any package), and within any other class in the same package. `Protected` access provides a balance between `public` and `private`, allowing subclasses to inherit and access members while restricting access from unrelated classes in other packages. The default access modifier (when no explicit modifier is specified) means that the member is accessible only within the same package. This is also known as package-private access. Classes in other packages cannot access members with default access, even if they are subclasses. We'll illustrate the differences in accessibility with examples. We'll create classes in different packages and demonstrate which members are accessible from where based on their access modifiers. A table summarizing the accessibility rules for each modifier will be provided. It's important to choose the appropriate access modifier for each member of your classes based on the desired level of visibility and the principles of encapsulation. For example, instance variables are often declared as `private` to prevent direct external access and ensure that their values are modified only through public methods (getters and setters). Public methods provide controlled access to the object's state and behavior. We'll also discuss the access modifiers that can be used for top-level classes and interfaces. Top-level classes and interfaces can only be `public` or default (package-private). They cannot be `private` or `protected`, as these modifiers are relevant in the context of nested classes and inheritance. Understanding access modifiers is crucial for designing well-structured and maintainable object-oriented programs in Java. By carefully controlling the visibility of your class members, you can improve the robustness and security of your code and promote better code organization. We'll also touch upon the concept of encapsulation, which involves bundling data (attributes) and the methods that operate on the data together, and using access modifiers to restrict direct access to the data.",
      "duration_minutes": 55,
      "keywords": ["Java", "OOP", "Access Modifiers", "Public", "Private", "Protected", "Default", "Package-Private", "Encapsulation"]
    },
    {
      "lecture_id": 13,
      "week_id": 8,
      "order": 1,
      "title": "Inheritance in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_inheritance.mp4",
      "content_transcript": "Welcome to this lecture on inheritance, one of the core principles of object-oriented programming in Java. Inheritance is a mechanism by which a new class (subclass or derived class) can inherit the properties (attributes and methods) of an existing class (superclass or base class). This promotes code reusability and establishes an 'is-a' relationship between classes. In Java, inheritance is achieved using the `extends` keyword. When you declare a class to extend another class, it automatically gains access to the non-private members of the superclass. For example: `public class Animal { String name; public void eat() { System.out.println('Animal is eating'); } } public class Dog extends Animal { String breed; public void bark() { System.out.println('Dog is barking'); } }` In this example, `Dog` is a subclass of `Animal`. A `Dog` object can access the `name` attribute and the `eat()` method inherited from the `Animal` class, in addition to its own `breed` attribute and `bark()` method. We'll discuss the benefits of inheritance, such as code reuse, reducing redundancy, and improving maintainability. Inheritance also forms the basis for polymorphism, which we'll cover in the next lecture. A subclass can override the methods of its superclass. Method overriding occurs when a subclass provides a different implementation for a method that is already defined in its superclass. The method in the subclass must have the same name, return type, and parameter list as the method in the superclass. The `@Override` annotation can be used to indicate that a method is intended to override a superclass method, which helps in catching errors at compile time. We'll look at examples of method overriding and understand how it allows subclasses to customize the behavior inherited from the superclass. Java supports single inheritance, meaning a class can extend only one direct superclass. However, a class can implement multiple interfaces, which provides a form of multiple inheritance of type. We'll discuss interfaces in more detail later. The `super` keyword is used in a subclass to refer to its immediate superclass. You can use `super` to call a superclass constructor (as the first statement in a subclass constructor) or to access superclass methods or attributes that have been overridden or hidden by the subclass. We'll demonstrate how to use the `super` keyword in different scenarios. The concept of the class hierarchy is important in inheritance. Classes form a hierarchical structure where subclasses inherit from superclasses, which might in turn inherit from other superclasses, ultimately leading up to the `Object` class, which is the root of the Java class hierarchy. All Java classes implicitly or explicitly inherit from the `Object` class. We'll briefly discuss some of the common methods provided by the `Object` class, such as `toString()`, `equals()`, and `hashCode()`. Understanding inheritance is fundamental to object-oriented design in Java. It allows you to create more specialized classes based on more general ones, promoting code reuse and a clear organizational structure. We'll work through several examples to illustrate the concepts of inheritance, method overriding, and the use of the `super` keyword.",
      "duration_minutes": 60,
      "keywords": ["Java", "OOP", "Inheritance", "Superclass", "Subclass", "Extends", "Method Overriding", "Super Keyword", "Class Hierarchy"]
    },
    {
      "lecture_id": 14,
      "week_id": 8,
      "order": 2,
      "title": "Polymorphism and Abstract Classes in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week6_Lecture2.pdf",
      "content_extract": "In this lecture, we will explore polymorphism and abstract classes in Java. Polymorphism, which literally means 'many forms', is a powerful concept in OOP that allows objects of different classes to be treated as objects of a common superclass type. This enables you to write more flexible and extensible code. There are two main types of polymorphism in Java: compile-time (or static) polymorphism and runtime (or dynamic) polymorphism. Compile-time polymorphism is achieved through method overloading, where a single class has multiple methods with the same name but different parameter lists. The compiler determines which method to call based on the arguments passed. Runtime polymorphism, on the other hand, is achieved through method overriding and inheritance. A superclass reference variable can refer to an object of any of its subclasses. When a method is called on this reference, the actual method implementation to be executed is determined at runtime based on the actual type of the object, not the type of the reference. This is also known as dynamic method dispatch. We'll illustrate runtime polymorphism with examples, showing how a single method call on a superclass reference can result in different behavior depending on the subclass object it refers to. Upcasting (assigning a subclass object to a superclass reference) is automatically allowed, while downcasting (assigning a superclass reference to a subclass reference) requires an explicit cast and can lead to `ClassCastException` if the object is not actually an instance of the target subclass. Abstract classes are classes that cannot be instantiated directly. They are declared using the `abstract` keyword and can contain abstract methods (methods without a body) as well as concrete methods (methods with a body). If a class contains any abstract methods, the class itself must be declared as abstract. Subclasses of an abstract class must either implement all the abstract methods of their superclass or be declared as abstract themselves. Abstract classes provide a way to define a common template or blueprint for a group of related classes. They can enforce certain methods to be implemented by their subclasses while also providing common functionality through concrete methods. Abstract methods are declared using the `abstract` keyword and do not have an implementation (no curly braces after the method signature, just a semicolon). For example: `public abstract class Shape { public abstract double getArea(); public void displayColor(String color) { System.out.println('Color: ' + color); } }` Here, `getArea()` is an abstract method, and `displayColor()` is a concrete method. Subclasses of `Shape` (like `Rectangle` or `Circle`) would need to provide their own implementation for `getArea()`. We'll discuss the purpose of abstract classes and abstract methods and when it's appropriate to use them. They are often used to model abstract concepts or to ensure that certain behaviors are implemented by all subclasses. We'll also briefly touch upon interfaces (which we'll cover in more detail later), which provide another way to achieve abstraction in Java. Understanding polymorphism and abstract classes is crucial for designing flexible and extensible object-oriented systems in Java. They allow you to write code that can work with objects of different types in a uniform way and to define common structures for related classes.",
      "duration_minutes": 65,
      "keywords": ["Java", "OOP", "Polymorphism", "Compile-Time Polymorphism", "Runtime Polymorphism", "Method Overloading", "Method Overriding", "Abstract Class", "Abstract Method"]
    },
    {
      "lecture_id": 15,
      "week_id": 9,
      "order": 1,
      "title": "Exception Handling in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_exceptions.mp4",
      "content_transcript": "Welcome to this lecture on exception handling in Java. Exceptions are events that occur during the execution of a program that disrupt the normal flow of instructions. Java provides a powerful mechanism to handle these runtime errors gracefully, preventing your program from crashing. The process of responding to exceptions is known as exception handling. Java categorizes exceptions into two main types: checked exceptions and unchecked exceptions. Checked exceptions are exceptions that the compiler forces you to handle (using a `try-catch` block or by declaring that your method `throws` the exception). These typically represent exceptional conditions that a well-written program should anticipate and recover from (e.g., `IOException`, `SQLException`). Unchecked exceptions (also known as runtime exceptions) are exceptions that the compiler does not force you to handle. These usually result from programming errors (e.g., `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`). Errors are another category of throwable objects, but they typically represent more serious problems that a program usually cannot recover from (e.g., `OutOfMemoryError`, `StackOverflowError`). The core of exception handling in Java is the `try-catch` block. You place the code that might throw an exception inside a `try` block. If an exception occurs within the `try` block, the normal flow of execution is interrupted, and control is transferred to a matching `catch` block. A `catch` block specifies the type of exception it can handle and contains the code to be executed if an exception of that type (or a subclass) occurs. You can have multiple `catch` blocks to handle different types of exceptions that might be thrown in the `try` block. The syntax of a `try-catch` block is: `try { // code that might throw an exception } catch (ExceptionType1 e1) { // code to handle ExceptionType1 } catch (ExceptionType2 e2) { // code to handle ExceptionType2 } // ...`. There is also an optional `finally` block that can follow the `try` and `catch` blocks. The code in the `finally` block is always executed, regardless of whether an exception was thrown in the `try` block or whether a matching `catch` block was found. The `finally` block is typically used for cleanup operations, such as closing files or releasing resources. You can also explicitly throw exceptions using the `throw` keyword. This is useful for signaling error conditions in your own methods. When you throw a checked exception in a method, you must either handle it within the method using a `try-catch` block or declare that the method `throws` that exception in its method signature. This informs the calling method that it might need to handle the exception. We'll look at examples of using `try-catch-finally` blocks, throwing exceptions, and handling different types of checked and unchecked exceptions. Understanding the exception hierarchy in Java (which is rooted in the `Throwable` class) is important for effectively catching and handling exceptions. We'll discuss some of the common built-in exception classes and how to choose the appropriate exception type to catch. Proper exception handling is crucial for writing robust and reliable Java programs. It allows you to anticipate potential problems and provide mechanisms to recover from them or to terminate gracefully. We'll also discuss best practices for exception handling, such as catching specific exception types rather than just the generic `Exception` class, and using exceptions for exceptional conditions, not for normal program flow.",
      "duration_minutes": 55,
      "keywords": ["Java", "Exception Handling", "Exceptions", "Checked Exceptions", "Unchecked Exceptions", "Try-Catch", "Finally", "Throw", "Throwable"]
    },
    {
      "lecture_id": 16,
      "week_id": 9,
      "order": 2,
      "title": "Working with ArrayList in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week7_Lecture2.pdf",
      "content_extract": "In this lecture, we'll introduce the Java Collections Framework and focus on the `ArrayList` class. The Java Collections Framework provides a set of interfaces and classes for storing and manipulating groups of objects. `ArrayList` is a resizable array implementation of the `List` interface. It allows you to store a dynamic number of elements and provides methods for adding, removing, accessing, and searching for elements. To use `ArrayList`, you need to import it from the `java.util` package: `import java.util.ArrayList;`. You create an `ArrayList` object by specifying the type of elements it will hold within angle brackets (generics). For example, to create an `ArrayList` that can hold `String` objects: `ArrayList<String> names = new ArrayList<>();`. You can add elements to an `ArrayList` using the `add()` method. There are two versions of `add()`: one that adds the element to the end of the list, and another that inserts the element at a specific index. For example: `names.add('Alice'); names.add('Bob'); names.add(0, 'Charlie');` This will result in the list containing 'Charlie', 'Alice', 'Bob'. You can access elements in an `ArrayList` using the `get()` method, which takes the index of the element as an argument (indices are 0-based). For example: `String firstElement = names.get(0);` You can find the number of elements in an `ArrayList` using the `size()` method. For example: `int numberOfNames = names.size();`. To remove elements from an `ArrayList`, you can use the `remove()` method, which can either take the index of the element to be removed or the element itself as an argument. For example: `names.remove(1);` (removes the element at index 1) or `names.remove('Bob');` (removes the first occurrence of 'Bob'). You can check if an `ArrayList` contains a specific element using the `contains()` method, which returns a boolean value. For example: `boolean hasAlice = names.contains('Alice');`. You can find the index of the first occurrence of an element using the `indexOf()` method, and the index of the last occurrence using `lastIndexOf()`. If the element is not found, these methods return -1. You can iterate over the elements of an `ArrayList` using a `for` loop with an index, or by using an enhanced `for` loop (for-each loop): `for (String name : names) { System.out.println(name); }`. We'll look at examples of performing common operations on `ArrayLists`, such as adding, accessing, updating, and removing elements, as well as iterating through the list. We'll also discuss the concept of generics and type safety in collections. By specifying the type of elements an `ArrayList` can hold, you prevent accidental insertion of elements of the wrong type, which can lead to runtime errors. `ArrayList` is a dynamic data structure, meaning its size can grow or shrink as you add or remove elements. This is a key advantage over traditional arrays, whose size is fixed at the time of creation. We'll briefly compare `ArrayList` with arrays and discuss when it might be more appropriate to use one over the other. Understanding how to use `ArrayList` is fundamental to working with collections of objects in Java. It's a versatile and commonly used class for managing lists of data. We'll also touch upon other basic operations like clearing the entire list using `clear()` and checking if the list is empty using `isEmpty()`.",
      "duration_minutes": 60,
      "keywords": ["Java", "Collections", "ArrayList", "List", "Add", "Get", "Remove", "Size", "Iteration"]
    },
    {
      "lecture_id": 17,
      "week_id": 10,
      "order": 1,
      "title": "Working with LinkedList in Java",
      "resource_type": "youtube",
      "video_url": "https://www.example.com/java_linkedlist.mp4",
      "content_transcript": "In this lecture, we'll continue our exploration of the Java Collections Framework by focusing on the `LinkedList` class. Like `ArrayList`, `LinkedList` also implements the `List` interface, but it has a different underlying data structure. While `ArrayList` uses a dynamic array to store elements, `LinkedList` uses a doubly-linked list. This difference in implementation leads to different performance characteristics for certain operations. To use `LinkedList`, you need to import it from the `java.util` package: `import java.util.LinkedList;`. You create a `LinkedList` object similarly to `ArrayList`, by specifying the type of elements it will hold: `LinkedList<String> tasks = new LinkedList<>();`. Adding elements to a `LinkedList` is efficient, especially at the beginning or end of the list, as it only involves updating the links between nodes. `LinkedList` provides methods like `add(element)` to add to the end, `addFirst(element)` to add to the beginning, and `addLast(element)` (which is the same as `add()`). It also has an `add(index, element)` method to insert at a specific position. For example: `tasks.add('Task 1'); tasks.addFirst('Task 0'); tasks.addLast('Task 2'); tasks.add(1, 'Task 1.5');`. Accessing elements in a `LinkedList` by index can be less efficient compared to `ArrayList`, as it requires traversing the list from the beginning (or end, if the index is closer to the end) to the desired position. The `get(index)` method is used to retrieve an element at a specific index. `LinkedList` also provides methods to get the first and last elements: `getFirst()` and `getLast()`. Removing elements from a `LinkedList` is also efficient if you have a reference to the element or its position. Methods like `remove()`, `remove(index)`, `removeFirst()`, and `removeLast()` are available. `remove()` without an argument removes the first occurrence of the specified element. You can get the size of the `LinkedList` using the `size()` method, and you can check if it's empty using `isEmpty()`. Iterating through a `LinkedList` can be done using an iterator, a for-each loop, or a traditional for loop (though the latter is generally less efficient for `LinkedList` due to the cost of random access). The `Iterator` interface provides methods like `hasNext()` and `next()` to traverse the collection. `LinkedList` also implements the `Deque` (Double Ended Queue) interface, which means it supports operations for adding and removing elements from both ends. This makes it suitable for implementing stacks and queues. We'll look at examples of using `LinkedList` for these purposes. We'll compare the performance characteristics of `ArrayList` and `LinkedList` for different operations (adding, removing, accessing). `ArrayList` generally offers better performance for random access (getting an element by index), while `LinkedList` is more efficient for insertions and deletions, especially at the beginning or end of the list. Understanding the strengths and weaknesses of each data structure is important for choosing the appropriate one for your specific needs. We'll also discuss scenarios where `LinkedList` might be a better choice than `ArrayList`, such as when you need frequent insertions or deletions at arbitrary positions in the list, or when you need to implement a stack or a queue. While `ArrayList` is often the default choice for a list, `LinkedList` provides valuable alternatives when performance requirements differ.",
      "duration_minutes": 60,
      "keywords": ["Java", "Collections", "LinkedList", "List", "AddFirst", "AddLast", "Get", "Remove", "Deque", "Performance"]
    },
    {
      "lecture_id": 18,
      "week_id": 10,
      "order": 2,
      "title": "Working with HashSet in Java",
      "resource_type": "pdf",
      "file_path": "JAVA101_Week8_Lecture2.pdf",
      "content_extract": "In this lecture, we'll explore the `HashSet` class, which is another important part of the Java Collections Framework. `HashSet` implements the `Set` interface, which means it stores a collection of unique elements. Unlike lists, sets do not maintain any specific order of elements. The `HashSet` internally uses a hash table for storage, which provides efficient performance for basic operations like adding, removing, and checking for the presence of elements. To use `HashSet`, you need to import it from the `java.util` package: `import java.util.HashSet;`. You create a `HashSet` object by specifying the type of elements it will hold: `HashSet<String> uniqueNames = new HashSet<>();`. You can add elements to a `HashSet` using the `add()` method. If you try to add an element that is already present in the set, the `add()` method will return `false`, and the set will not be modified (as sets only store unique elements). For example: `uniqueNames.add('Alice'); uniqueNames.add('Bob'); boolean added = uniqueNames.add('Alice'); // added will be false`. You can check if a `HashSet` contains a specific element using the `contains()` method, which returns a boolean value. For example: `boolean hasBob = uniqueNames.contains('Bob');`. To remove an element from a `HashSet`, you can use the `remove()` method, which takes the element to be removed as an argument and returns `true` if the element was found and removed, `false` otherwise. For example: `boolean removed = uniqueNames.remove('Bob');`. You can find the number of elements in a `HashSet` using the `size()` method, and you can check if it's empty using `isEmpty()`. Iterating over the elements of a `HashSet` can be done using an iterator or a for-each loop. Since `HashSet` does not guarantee any specific order, the order in which elements are returned during iteration might not be predictable. For example: `for (String name : uniqueNames) { System.out.println(name); }`. The efficiency of `HashSet` operations (like `add`, `remove`, `contains`) is typically constant time (O(1)) on average, assuming a good hash function and proper distribution of elements in the hash table. This makes `HashSet` a good choice when you need to store a collection of unique elements and perform frequent checks for their presence. We'll discuss the importance of the `hashCode()` and `equals()` methods when using objects in a `HashSet`. For `HashSet` to correctly identify duplicate objects, the `hashCode()` and `equals()` methods of the object class must be properly implemented. Two objects are considered equal by a `HashSet` if their `equals()` method returns `true` and they have the same hash code (as returned by their `hashCode()` method). We'll look at examples of how to implement these methods correctly. We'll also briefly touch upon other implementations of the `Set` interface in the Java Collections Framework, such as `TreeSet` (which stores elements in a sorted order) and `LinkedHashSet` (which maintains the order of insertion). Understanding `HashSet` is essential for managing collections of unique items efficiently in Java. It provides a powerful tool for tasks like removing duplicates from a list or checking for the existence of an element in a collection.",
      "duration_minutes": 55,
      "keywords": ["Java", "Collections", "HashSet", "Set", "Add", "Contains", "Remove", "Unique Elements", "HashCode", "Equals"]
    }
  ],

	"assignments": [
  {
    "assignment_id": 3,
    "week_id": 3,
    "title": "Java Setup and Basics",
    "description": "Verify your Java development environment setup and practice basic Java syntax.",
    "type": "practice",
    "due_date": "2025-04-12",
    "start_date": "2025-04-05",
    "is_published": true,
    "question_ids": [1, 7, 10, 11, 15, 25]
  },
  {
    "assignment_id": 4,
    "week_id": 4,
    "title": "Data Types and Operators",
    "description": "Practice using different data types and operators in Java.",
    "type": "practice",
    "due_date": "2025-04-19",
    "start_date": "2025-04-12",
    "is_published": true,
    "question_ids": [2, 5, 9, 16, 18, 22]
  },
  {
    "assignment_id": 5,
    "week_id": 5,
    "title": "Control Flow Statements",
    "description": "Implement programs using if-else, switch statements, and for, while, and do-while loops.",
    "type": "graded",
    "due_date": "2025-04-26",
    "start_date": "2025-04-19",
    "is_published": true,
    "question_ids": [3, 6, 12, 19, 26, 27]
  },
  {
    "assignment_id": 6,
    "week_id": 6,
    "title": "Classes and Objects",
    "description": "Design and implement simple Java classes and create objects.",
    "type": "graded",
    "due_date": "2025-05-03",
    "start_date": "2025-04-26",
    "is_published": true,
    "question_ids": [4, 8, 17, 21, 24, 33]
  },
  {
    "assignment_id": 7,
    "week_id": 7,
    "title": "Constructors and Access Modifiers",
    "description": "Implement classes with different types of constructors and various access modifiers.",
    "type": "practice",
    "due_date": "2025-05-10",
    "start_date": "2025-05-03",
    "is_published": true,
    "question_ids": [13, 14, 20, 23, 35, 39]
  },
  {
    "assignment_id": 8,
    "week_id": 8,
    "title": "Inheritance and Polymorphism",
    "description": "Implement class hierarchies using inheritance and demonstrate polymorphism.",
    "type": "graded",
    "due_date": "2025-05-17",
    "start_date": "2025-05-10",
    "is_published": true,
    "question_ids": [28, 29, 30, 31, 37, 44]
  },
  {
    "assignment_id": 9,
    "week_id": 9,
    "title": "Exception Handling",
    "description": "Write code to handle potential exceptions using try-catch blocks.",
    "type": "practice",
    "due_date": "2025-05-24",
    "start_date": "2025-05-17",
    "is_published": true,
    "question_ids": [32, 34, 36, 43, 45, 46]
  },
  {
    "assignment_id": 10,
    "week_id": 10,
    "title": "Introduction to Collections",
    "description": "Work with ArrayList, LinkedList, and HashSet to store and manipulate collections of objects.",
    "type": "graded",
    "due_date": "2025-05-31",
    "start_date": "2025-05-24",
    "is_published": true,
    "question_ids": [38, 40, 41, 47, 49, 55]
  }
],

  "questions": [
    {
      "question_id": 9,
      "content": "What is the output of the following Java code snippet? `System.out.println('Hello' + ' ' + 'Java');`",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Hello Java",
      "points": 5,
      "explanation": "The `+` operator concatenates the strings.",
      "course_id": 2,
      "week_id": 3,
      "lecture_id": 3,
      "status": "active",
      "tags": ["java", "syntax", "output"]
    },
    {
      "question_id": 10,
      "content": "Which of the following is the correct way to declare an integer variable named 'count' and initialize it to 0 in Java?",
      "type": "MCQ",
      "question_options": ["int count = 0;", "integer count = 0;", "Count int = 0;", "0 = int count;"],
      "correct_answer": 0,
      "points": 5,
      "explanation": "The correct syntax is `dataType variableName = value;`",
      "course_id": 2,
      "week_id": 3,
      "lecture_id": 3,
      "status": "active",
      "tags": ["java", "syntax", "variables"]
    },
    {
      "question_id": 11,
      "content": "What is the name of the command used to compile a Java source code file from the command line?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "javac",
      "points": 5,
      "explanation": "`javac` is the Java compiler.",
      "course_id": 2,
      "week_id": 3,
      "lecture_id": 3,
      "status": "active",
      "tags": ["java", "setup", "compiler"]
    },
    {
      "question_id": 12,
      "content": "Explain the purpose of the Java Virtual Machine (JVM).",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The JVM is responsible for executing Java bytecode. It provides a runtime environment that enables Java code to run on any platform with a compatible JVM.",
      "points": 10,
      "explanation": "The JVM provides platform independence for Java programs.",
      "course_id": 2,
      "week_id": 3,
      "lecture_id": 3,
      "status": "active",
      "tags": ["java", "jvm", "architecture"]
    },
    {
      "question_id": 13,
      "content": "Identify the keywords in the following Java code snippet: `public static void main(String[] args)`",
      "type": "MSQ",
      "question_options": ["public", "static", "void", "main", "String", "args"],
      "correct_answer": [2, 3],
      "points": 8,
      "explanation": "`public`, `static`, and `void` are keywords. `main`, `String`, and `args` are identifiers.",
      "course_id": 2,
      "week_id": 3,
      "lecture_id": 3,
      "status": "active",
      "tags": ["java", "syntax", "keywords"]
    },
    {
      "question_id": 14,
      "content": "What is the size in bits of the `int` primitive data type in Java?",
      "type": "NUMERIC",
      "question_options": [],
      "correct_answer": 32,
      "points": 5,
      "explanation": "An `int` in Java is a 32-bit signed integer.",
      "course_id": 2,
      "week_id": 4,
      "lecture_id": 5,
      "status": "active",
      "tags": ["java", "data types", "primitive"]
    },
    {
      "question_id": 15,
      "content": "Which of the following is NOT a primitive data type in Java?",
      "type": "MCQ",
      "question_options": ["int", "boolean", "String", "char"],
      "correct_answer": 2,
      "points": 5,
      "explanation": "`String` is a class in Java, not a primitive data type.",
      "course_id": 2,
      "week_id": 4,
      "lecture_id": 5,
      "status": "active",
      "tags": ["java", "data types", "primitive"]
    },
    {
      "question_id": 16,
      "content": "What is the result of the expression `5 / 2` in Java?",
      "type": "NUMERIC",
      "question_options": [],
      "correct_answer": 2,
      "points": 5,
      "explanation": "Integer division in Java truncates the decimal part.",
      "course_id": 2,
      "week_id": 4,
      "lecture_id": 6,
      "status": "active",
      "tags": ["java", "operators", "arithmetic"]
    },
    {
      "question_id": 17,
      "content": "Explain the difference between the `==` operator and the `.equals()` method when comparing objects in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The `==` operator compares object references (whether they point to the same object in memory), while the `.equals()` method compares the content or state of the objects.",
      "points": 10,
      "explanation": "It's important to use `.equals()` to compare the logical equality of objects.",
      "course_id": 2,
      "week_id": 4,
      "lecture_id": 6,
      "status": "active",
      "tags": ["java", "operators", "equals", "comparison"]
    },
    {
      "question_id": 18,
      "content": "What will be the value of `x` after the execution of the following code? `int x = 10; x += 5;`",
      "type": "NUMERIC",
      "question_options": [],
      "correct_answer": 15,
      "points": 5,
      "explanation": "The `+=` operator adds the right operand to the left operand and assigns the result to the left operand.",
      "course_id": 2,
      "week_id": 4,
      "lecture_id": 6,
      "status": "active",
      "tags": ["java", "operators", "assignment"]
    },
    {
      "question_id": 19,
      "content": "Write a Java `if-else` statement that checks if an integer variable `num` is positive. If it is, print 'Positive'; otherwise, print 'Not Positive'.",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "if (num > 0) { System.out.println('Positive'); } else { System.out.println('Not Positive'); }",
      "points": 10,
      "explanation": "This code correctly uses an `if-else` statement to check the condition.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 7,
      "status": "active",
      "tags": ["java", "control flow", "if-else"]
    },
    {
      "question_id": 20,
      "content": "What is the output of the following Java code snippet? `int i = 0; while (i < 3) { System.out.println(i); i++; }`",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "0\n1\n2",
      "points": 5,
      "explanation": "The `while` loop iterates as long as the condition `i < 3` is true.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 8,
      "status": "active",
      "tags": ["java", "control flow", "while loop", "output"]
    },
    {
      "question_id": 21,
      "content": "Explain the difference between a `while` loop and a `do-while` loop in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A `while` loop checks the condition before executing the loop body, so the body might not execute at all if the condition is initially false. A `do-while` loop executes the loop body at least once before checking the condition.",
      "points": 10,
      "explanation": "The `do-while` loop guarantees at least one execution.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 8,
      "status": "active",
      "tags": ["java", "control flow", "while loop", "do-while loop"]
    },
    {
      "question_id": 22,
      "content": "Write a Java `for` loop that prints numbers from 1 to 5 (inclusive).",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "for (int i = 1; i <= 5; i++) { System.out.println(i); }",
      "points": 10,
      "explanation": "This `for` loop initializes `i` to 1, continues as long as `i` is less than or equal to 5, and increments `i` after each iteration.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 8,
      "status": "active",
      "tags": ["java", "control flow", "for loop"]
    },
    {
      "question_id": 23,
      "content": "What will be the output of the following Java code snippet? `for (int i = 0; i < 5; i++) { if (i == 3) { break; } System.out.println(i); }`",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "0\n1\n2",
      "points": 5,
      "explanation": "The `break` statement terminates the loop when `i` equals 3.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 8,
      "status": "active",
      "tags": ["java", "control flow", "for loop", "break", "output"]
    },
    {
      "question_id": 24,
      "content": "Explain the purpose of the `switch` statement in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The `switch` statement is used to execute one of several blocks of code based on the value of a single variable or expression.",
      "points": 8,
      "explanation": "It provides an alternative to multiple `if-else if` statements when comparing a single value against several constant values.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 7,
      "status": "active",
      "tags": ["java", "control flow", "switch statement"]
    },
    {
      "question_id": 25,
      "content": "What is the role of the `default` case in a `switch` statement?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The `default` case specifies the code to be executed if the value of the switch expression does not match any of the `case` values.",
      "points": 5,
      "explanation": "It's like the `else` in an `if-else if` ladder.",
      "course_id": 2,
      "week_id": 5,
      "lecture_id": 7,
      "status": "active",
      "tags": ["java", "control flow", "switch statement", "default"]
    },
    {
      "question_id": 26,
      "content": "Define a Java class named `Rectangle` with two instance variables: `width` (int) and `height` (int).",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "public class Rectangle { int width; int height; }",
      "points": 10,
      "explanation": "This code correctly defines the `Rectangle` class with the specified instance variables.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 9,
      "status": "active",
      "tags": ["java", "oop", "classes", "instance variables"]
    },
    {
      "question_id": 27,
      "content": "Explain the difference between a class and an object in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A class is a blueprint or template for creating objects, defining their structure (attributes) and behavior (methods). An object is an instance of a class, a concrete entity created based on the class definition.",
      "points": 10,
      "explanation": "Think of a class as a cookie cutter and an object as a cookie.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 9,
      "status": "active",
      "tags": ["java", "oop", "classes", "objects"]
    },
    {
      "question_id": 28,
      "content": "How do you create an object of the `Rectangle` class (defined in the previous question) in Java?",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "Rectangle myRect = new Rectangle();",
      "points": 5,
      "explanation": "The `new` keyword is used to create an object, followed by a call to the constructor.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 10,
      "status": "active",
      "tags": ["java", "oop", "objects", "instantiation"]
    },
    {
      "question_id": 29,
      "content": "Write a method named `calculateArea` inside the `Rectangle` class that returns the area of the rectangle (width * height).",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "public int calculateArea() { return width * height; }",
      "points": 10,
      "explanation": "This method correctly calculates and returns the area.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 9,
      "status": "active",
      "tags": ["java", "oop", "classes", "methods"]
    },
    {
      "question_id": 30,
      "content": "What is the purpose of instance variables in a class?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Instance variables (also known as attributes or fields) store the data or state of an object of the class. Each object has its own copy of the instance variables.",
      "points": 8,
      "explanation": "They define the characteristics of an object.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 9,
      "status": "active",
      "tags": ["java", "oop", "classes", "instance variables"]
    },
    {
      "question_id": 31,
      "content": "How do you access the instance variables of an object in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "You access instance variables using the dot operator (`.`) followed by the variable name, e.g., `objectName.variableName`.",
      "points": 5,
      "explanation": "The dot operator is used to access members of an object.",
      "course_id": 2,
      "week_id": 6,
      "lecture_id": 10,
      "status": "active",
      "tags": ["java", "oop", "objects", "accessing attributes"]
    },
    {
      "question_id": 32,
      "content": "What is a constructor in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A constructor is a special method in a class that is automatically called when an object of that class is created. It is used to initialize the object's state.",
      "points": 8,
      "explanation": "Constructors have the same name as the class and no return type.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 11,
      "status": "active",
      "tags": ["java", "oop", "constructors"]
    },
    {
      "question_id": 33,
      "content": "Define a constructor for the `Rectangle` class that takes `width` and `height` as parameters and initializes the instance variables.",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "public Rectangle(int w, int h) { width = w; height = h; }",
      "points": 10,
      "explanation": "This is a parameterized constructor.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 11,
      "status": "active",
      "tags": ["java", "oop", "constructors", "parameterized constructor"]
    },
    {
      "question_id": 34,
      "content": "What is a default constructor in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A default constructor is a no-argument constructor that is automatically provided by the Java compiler if no constructors are explicitly defined in the class. It initializes instance variables to their default values.",
      "points": 8,
      "explanation": "Once you define a constructor, the default constructor is no longer provided automatically.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 11,
      "status": "active",
      "tags": ["java", "oop", "constructors", "default constructor"]
    },
    {
      "question_id": 35,
      "content": "Explain the purpose of access modifiers in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Access modifiers control the visibility and accessibility of classes, interfaces, variables, methods, and constructors.",
      "points": 8,
      "explanation": "They help in implementing encapsulation and controlling the scope of members.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 12,
      "status": "active",
      "tags": ["java", "oop", "access modifiers"]
    },
    {
      "question_id": 36,
      "content": "List the four access modifiers in Java and briefly describe their visibility.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "- `public`: Accessible from anywhere.\n- `private`: Accessible only within the declaring class.\n- `protected`: Accessible within the class, subclasses, and classes in the same package.\n- default (package-private): Accessible only within the same package.",
      "points": 12,
      "explanation": "Understanding the scope of each modifier is crucial.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 12,
      "status": "active",
      "tags": ["java", "oop", "access modifiers"]
    },
    {
      "question_id": 37,
      "content": "When should you declare an instance variable as `private`?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "You should declare an instance variable as `private` to hide it from direct external access and to enforce encapsulation, meaning its values can only be accessed and modified through controlled public methods (getters and setters).",
      "points": 10,
      "explanation": "`private` access helps in maintaining the integrity of the object's state.",
      "course_id": 2,
      "week_id": 7,
      "lecture_id": 12,
      "status": "active",
      "tags": ["java", "oop", "access modifiers", "private", "encapsulation"]
    },
    {
      "question_id": 38,
      "content": "What is inheritance in object-oriented programming?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Inheritance is a mechanism by which a new class (subclass) can inherit the properties (attributes and methods) of an existing class (superclass).",
      "points": 8,
      "explanation": "It promotes code reusability and establishes an 'is-a' relationship.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 13,
      "status": "active",
      "tags": ["java", "oop", "inheritance"]
    },
    {
      "question_id": 39,
      "content": "How is inheritance achieved in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Inheritance is achieved in Java using the `extends` keyword in the class declaration of the subclass, followed by the name of the superclass.",
      "points": 5,
      "explanation": "Example: `public class Dog extends Animal { ... }`",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 13,
      "status": "active",
      "tags": ["java", "oop", "inheritance", "extends"]
    },
    {
      "question_id": 40,
      "content": "Explain the concept of method overriding in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Method overriding occurs when a subclass provides a different implementation for a method that is already defined in its superclass. The method in the subclass must have the same name, return type, and parameter list.",
      "points": 10,
      "explanation": "It allows subclasses to customize inherited behavior.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 13,
      "status": "active",
      "tags": ["java", "oop", "inheritance", "method overriding"]
    },
    {
      "question_id": 41,
      "content": "What is polymorphism in object-oriented programming?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Polymorphism is the ability of an object to take on many forms. In Java, it allows objects of different classes to be treated as objects of a common superclass type.",
      "points": 8,
      "explanation": "It enables writing more flexible and extensible code.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 14,
      "status": "active",
      "tags": ["java", "oop", "polymorphism"]
    },
    {
      "question_id": 42,
      "content": "Explain the difference between compile-time polymorphism and runtime polymorphism in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Compile-time polymorphism (static binding) is achieved through method overloading. The compiler determines which method to call based on the method signature. Runtime polymorphism (dynamic binding) is achieved through method overriding. The JVM determines which method to call at runtime based on the actual object type.",
      "points": 12,
      "explanation": "The binding of the method call happens at different stages.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 14,
      "status": "active",
      "tags": ["java", "oop", "polymorphism", "compile-time", "runtime"]
    },
    {
      "question_id": 43,
      "content": "What is an abstract class in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "An abstract class is a class that cannot be instantiated directly. It is declared using the `abstract` keyword and can contain abstract methods (methods without a body) as well as concrete methods.",
      "points": 8,
      "explanation": "Abstract classes provide a template for subclasses.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 14,
      "status": "active",
      "tags": ["java", "oop", "abstract class"]
    },
    {
      "question_id": 44,
      "content": "What is an abstract method in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "An abstract method is a method that is declared using the `abstract` keyword and does not have an implementation (no method body). It must be implemented by any non-abstract subclass.",
      "points": 8,
      "explanation": "Abstract methods define a contract that subclasses must fulfill.",
      "course_id": 2,
      "week_id": 8,
      "lecture_id": 14,
      "status": "active",
      "tags": ["java", "oop", "abstract method"]
    },
    {
      "question_id": 45,
      "content": "What is an exception in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.",
      "points": 5,
      "explanation": "Exceptions are a form of runtime error handling.",
      "course_id": 2,
      "week_id": 9,
      "lecture_id": 15,
      "status": "active",
      "tags": ["java", "exception handling", "exceptions"]
    },
    {
      "question_id": 46,
      "content": "Explain the purpose of the `try-catch` block in Java.",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The `try` block encloses the code that might throw an exception. The `catch` block contains the code that is executed if a specific type of exception occurs in the `try` block.",
      "points": 8,
      "explanation": "It allows you to handle exceptions gracefully.",
      "course_id": 2,
      "week_id": 9,
      "lecture_id": 15,
      "status": "active",
      "tags": ["java", "exception handling", "try-catch"]
    },
    {
      "question_id": 47,
      "content": "What is the purpose of the `finally` block in a `try-catch` statement?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The `finally` block contains code that is always executed after the `try` block completes (either normally or due to an exception), and after any matching `catch` block has executed.",
      "points": 8,
      "explanation": "It's typically used for cleanup operations.",
      "course_id": 2,
      "week_id": 9,
      "lecture_id": 15,
      "status": "active",
      "tags": ["java", "exception handling", "finally"]
    },
    {
      "question_id": 48,
      "content": "What is the difference between checked and unchecked exceptions in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "Checked exceptions are exceptions that the compiler forces you to handle (either using `try-catch` or declaring `throws`). Unchecked exceptions (runtime exceptions) are not checked by the compiler and usually result from programming errors.",
      "points": 10,
      "explanation": "Checked exceptions represent potential issues that a program should anticipate.",
      "course_id": 2,
      "week_id": 9,
      "lecture_id": 15,
      "status": "active",
      "tags": ["java", "exception handling", "checked exceptions", "unchecked exceptions"]
    },
    {
      "question_id": 49,
      "content": "How do you explicitly throw an exception in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "You use the `throw` keyword followed by an instance of an exception class, e.g., `throw new IOException('File not found');`.",
      "points": 5,
      "explanation": "This is used to signal an error condition.",
      "course_id": 2,
      "week_id": 9,
      "lecture_id": 15,
      "status": "active",
      "tags": ["java", "exception handling", "throw"]
    },
    {
      "question_id": 50,
      "content": "What is the Java Collections Framework?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "The Java Collections Framework is a set of interfaces and classes that provide a way to store and manipulate groups of objects.",
      "points": 8,
      "explanation": "It offers reusable data structures.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 16,
      "status": "active",
      "tags": ["java", "collections"]
    },
    {
      "question_id": 51,
      "content": "What is an `ArrayList` in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "An `ArrayList` is a resizable array implementation of the `List` interface in Java. It can dynamically grow or shrink in size.",
      "points": 8,
      "explanation": "It's useful for storing ordered collections of elements.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 16,
      "status": "active",
      "tags": ["java", "collections", "arraylist", "list"]
    },
    {
      "question_id": 52,
      "content": "How do you add an element to an `ArrayList` named `myList`?",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "myList.add(element);",
      "points": 5,
      "explanation": "The `add()` method is used to append elements to the end of the list.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 16,
      "status": "active",
      "tags": ["java", "collections", "arraylist", "add"]
    },
    {
      "question_id": 53,
      "content": "What is a `LinkedList` in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A `LinkedList` is an implementation of the `List` and `Deque` interfaces that uses a doubly-linked list to store elements.",
      "points": 8,
      "explanation": "It's efficient for insertions and deletions.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 17,
      "status": "active",
      "tags": ["java", "collections", "linkedlist", "list", "deque"]
    },
    {
      "question_id": 54,
      "content": "When might you prefer using a `LinkedList` over an `ArrayList`?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "You might prefer `LinkedList` when you need frequent insertions and deletions of elements, especially at the beginning or end of the list, as these operations are more efficient in `LinkedList` than in `ArrayList`.",
      "points": 10,
      "explanation": "ArrayLists require shifting elements during insertions and deletions.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 17,
      "status": "active",
      "tags": ["java", "collections", "linkedlist", "arraylist", "performance"]
    },
    {
      "question_id": 55,
      "content": "What is a `HashSet` in Java?",
      "type": "SHORT_ANSWER",
      "question_options": [],
      "correct_answer": "A `HashSet` is an implementation of the `Set` interface that stores unique elements in a hash table. It does not guarantee any specific order of elements.",
      "points": 8,
      "explanation": "It's efficient for checking if an element exists in the set.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 18,
      "status": "active",
      "tags": ["java", "collections", "hashset", "set"]
    },
    {
      "question_id": 56,
      "content": "How do you add an element to a `HashSet` named `mySet`?",
      "type": "CODE",
      "question_options": [],
      "correct_answer": "mySet.add(element);",
      "points": 5,
      "explanation": "The `add()` method adds the element if it's not already present in the set.",
      "course_id": 2,
      "week_id": 10,
      "lecture_id": 18,
      "status": "active",
      "tags": ["java", "collections", "hashset", "add"]
    }
  ],
  "personal_resources": [
    {
      "resource_id": 2,
      "name": "Java Quick Syntax Guide",
      "description": "A quick reference for common Java syntax.",
      "course_id": 2,
      "user_id": 2002,
      "is_active": true,
      "LLM_Summary": {
        "summary": "Quick reference for Java syntax and common language features.",
        "concepts_covered": ["Basic syntax", "Data types", "Control structures", "OOP basics"],
        "concepts_not_covered": ["Advanced topics", "Frameworks"]
      }
    }
  ],
  "personal_resource_files": [
    {
      "file_id": 2,
      "resource_id": 2,
      "name": "Java Syntax Cheat Sheet",
      "type": "text",
      "content": "Quick reference for Java syntax, data types, operators, control flow, and basic OOP concepts.",
      "file_type": "text/markdown",
      "file_size": 6144
    }
  ]
}