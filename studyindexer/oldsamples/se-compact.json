{
    "course": {
        "course_id": 2,
        "code": "SE101",
        "title": "Software Engineering",
        "description": "A comprehensive course covering software engineering principles, processes, and best practices across the entire software development lifecycle, from requirements gathering to post-deployment maintenance. Emphasis is placed on practical applications, risk management, and modern software methodologies.",
        "instructor_id": 1002,
        "credits": 4,
        "department": "Computer Science",
        "image_url": "/assets/courses/se101/cover.jpg",
        "LLM_Summary": {
            "summary": "This course provides a comprehensive exploration of the Software Development Lifecycle (SDLC), covering the key phases: requirement gathering, system design, development, testing, deployment, and maintenance. It contrasts traditional plan-driven models (Waterfall, V-Model) with adaptive frameworks (Agile, Scrum), examining their strengths, limitations, and use cases. The course emphasizes practical applications such as documenting requirements using Software Requirements Specifications (SRS), creating design artifacts (UML diagrams, architectural blueprints), and implementing robust testing strategies (unit, integration, system, and user acceptance testing). Students learn about project estimation techniques, risk management strategies, and the importance of iterative feedback in modern agile development. Special focus is given to balancing documentation with flexibility, collaborating with stakeholders, and ensuring software quality through continuous testing and maintenance. By the end of the course, students will be equipped to design, manage, and deliver complex software systems while applying industry best practices.",
            "concepts_covered": [
            "Software development lifecycle phases (SDLC)",
            "Plan-driven vs. Agile methodologies",
            "Requirement gathering and specification (SRS creation)",
            "Software design principles and architectural patterns",
            "User interface and experience design best practices",
            "Project estimation (Function Point, COCOMO models)",
            "Scheduling techniques (Gantt charts, critical path method)",
            "Risk identification, assessment, and mitigation strategies",
            "Software testing methodologies (unit, integration, system, UAT)",
            "Maintenance categories: corrective, adaptive, perfective, preventive",
            "Change management and version control fundamentals",
            "Software quality assurance (SQA) and code reviews",
            "Ethical considerations and professional responsibility in software development"
            ],
            "concepts_not_covered": [
            "Advanced programming techniques (e.g., multithreading, concurrency)",
            "Specific implementation of DevOps and CI/CD pipelines",
            "Cloud-native software development and microservices",
            "Machine learning integration and AI-driven software engineering",
            "Enterprise-level security frameworks (e.g., OWASP, ISO 27001)"
            ]
        }
    },
  
    "weeks": [
      {
        "week_id": 1,
        "course_id": 2,
        "order": 1,
        "title": "Week 1: Deconstructing the Software Development Process",
        "estimated_hours": 25
      },
      {
        "week_id": 2,
        "course_id": 2,
        "order": 2,
        "title": "Week 2: Software Requirements",
        "estimated_hours": 25
      },
      {
        "week_id": 3,
        "course_id": 2,
        "order": 3,
        "title": "Week 3: Software User Interfaces",
        "estimated_hours": 25
      },
      {
        "week_id": 4,
        "course_id": 2,
        "order": 4,
        "title": "Week 4: Software Project Management",
        "estimated_hours": 25
      }
    ],
  
    "lectures": [
        {
            "lecture_id": 1,
            "week_id": 1,
            "order": 1,
            "title": "Deconstructing the Software Development Process",
            "resource_type": "youtube",
            "video_url": "https://www.youtube.com/watch?v=hKm_rh1RTJQ",
            "content_transcript": "",
            "duration_minutes": 45,
            "keywords": [
                "software engineering",
                "software processes",
                "tools",
                "inventory management",
                "payment gateway",
                "system components",
                "module integration"
            ],
            "LLM_Summary": {
                "summary": "This lecture provides a comprehensive introduction to software engineering, emphasizing the structured methodologies that guide the development of large-scale software systems. It begins by tracing the evolution of software engineering from an informal craft to a formal discipline built on standardized processes, models, and best practices. The lecture outlines three primary areas of focus: software processes, development tools, and code organization. Students are introduced to industry-standard processes like the waterfall and agile models, highlighting their core principles and real-world applications. The lecture also explores the critical role of tools in capturing requirements, planning, coding, and testing, illustrating how these tools facilitate the software development lifecycle. Additionally, it emphasizes best practices for writing clean, maintainable code and the importance of modular design in managing system complexity. Through a case study of Amazon’s platform, the lecture demonstrates how large systems are decomposed into components, focusing on the inventory management system and the payment gateway. This decomposition allows multiple teams to work independently while maintaining system coherence through well-defined interfaces. The learner-centric MOOC model is also discussed, which interleaves video content with reflective pauses, interactive activities, and discussion forums to enhance engagement. A key component of the course is a hands-on project where students apply theoretical concepts to build and deliver a software product, simulating the full software development lifecycle. This approach ensures a deep understanding of both the theoretical and practical aspects of modern software engineering.",
                "concepts_covered": [
                    "Evolution of software engineering",
                    "Software development processes (Waterfall, Agile)",
                    "Tools for software design and testing",
                    "Component-based system design",
                    "Inventory management systems",
                    "Payment gateway architecture",
                    "Module integration and communication",
                    "Learner-centric MOOC methodology",
                    "Reflection-based learning and engagement",
                    "Software development lifecycle through projects"
                ]
            }
        }
        ,
        {
            "lecture_id": 2,
            "week_id": 1,
            "order": 2,
            "title": "Software Development Lifecycle Models",
            "resource_type": "pdf",
            "resource_url": "https://drive.google.com/drive/folders/1ZR1SrDhrnvj43MaZrmEOhIyFXUKQh4mG",
            "content_extract": "",
            "duration_minutes": 90,
            "keywords": [
                "SDLC",
                "waterfall",
                "prototype",
                "spiral",
                "plan-and-document",
                "agile",
                "testing methodologies",
                "software maintenance"
            ],
            "LLM_Summary": {
                "summary": "This lecture provides a comprehensive exploration of various Software Development Lifecycle (SDLC) models, including traditional plan-driven approaches like the Waterfall model, which emphasizes a linear and sequential process with distinct phases, and iterative methods such as the Spiral and Prototype models, which focus on repeated cycles of development and refinement to accommodate evolving requirements. It also examines adaptive frameworks like Agile, which prioritize flexibility, rapid delivery, continuous feedback, and active client collaboration. The lecture systematically outlines the core phases of software development—requirement specification, design, development, testing, and maintenance—detailing the activities within each stage and the importance of clear documentation to ensure project traceability and quality assurance. A comparative analysis of these models is presented, emphasizing the strengths and limitations of each, such as the Waterfall model’s structured predictability versus Agile’s responsiveness to changing needs. Particular attention is given to the practical considerations when selecting an appropriate SDLC model based on project scope, complexity, stakeholder involvement, and delivery timelines. The lecture also emphasizes the critical role of comprehensive testing throughout the development lifecycle, covering methodologies such as unit testing for individual components, integration testing to ensure seamless interaction between modules, system testing for end-to-end validation, and user acceptance testing to verify that the final product meets client expectations. Additionally, it highlights the significance of ongoing maintenance activities, including bug fixes, performance enhancements, and adaptation to new technologies, which are essential for ensuring long-term software reliability, scalability, and compliance with evolving user needs and industry standards.",
                "concepts_covered": [
                    "Software Development Lifecycle (SDLC) overview",
                    "Phases of software development (requirement specification, design, development, testing, maintenance)",
                    "Waterfall model structure and limitations",
                    "Prototyping approach and its role in clarifying requirements",
                    "Spiral model's iterative nature and risk management benefits",
                    "Agile methodologies and their focus on flexibility and customer collaboration",
                    "Test-driven development (TDD) and its impact on code reliability",
                    "Comparative analysis of plan-driven vs. agile models",
                    "Role of documentation in different SDLC models",
                    "Maintenance and its importance in post-deployment software management"
                ],
                "concepts_not_covered": [
                    "In-depth backend system architecture",
                    "Advanced DevOps practices",
                    "Full-stack development specifics",
                    "Specialized agile frameworks (e.g., SAFe, LeSS)"
                ]
            }
        },
        {
            "lecture_id": 3,
            "week_id": 2,
            "order": 1,
            "title": "Requirement Gathering and Analysis",
            "resource_type": "youtube",
            "video_url": "https://www.youtube.com/watch?v=L9-CUa0BlLk&t=55s",
            "content_transcript": "",
            "duration_minutes": 50,
            "keywords": [
                "requirements",
                "stakeholders",
                "interviews",
                "questionnaires",
                "observation",
                "focus groups",
                "documentation"
            ],
            "LLM_Summary": {
                "summary": "This lecture explores various requirement-gathering techniques essential for developing complex software systems. It emphasizes the importance of identifying primary, secondary, and tertiary stakeholders and tailoring data collection methods accordingly. The lecture introduces key techniques, including structured and unstructured interviews for in-depth qualitative insights, questionnaires for gathering standardized responses from a large user base, and focus groups for consensus-building and uncovering conflicts. It also discusses naturalistic observation to capture unspoken user behaviors and documentation analysis for extracting regulatory and procedural requirements. Using the Amazon Seller Portal as a case study, the lecture highlights how these techniques collectively provide a comprehensive understanding of user needs. Additionally, best practices such as piloting data collection sessions and combining multiple techniques to mitigate bias and oversight are recommended to ensure robust requirement analysis.",
                "concepts_covered": [
                    "User classification (primary, secondary, tertiary users)",
                    "Interview techniques (structured, unstructured, semi-structured)",
                    "Questionnaires for large-scale data collection",
                    "Focus groups for consensus-building and conflict identification",
                    "Naturalistic observation to capture real-world behaviors",
                    "Documentation analysis for regulatory and procedural insights",
                    "Best practices in requirement gathering (pilot testing, combining techniques)"
                ]
            }
        },
        {
            "lecture_id": 4,
            "week_id": 2,
            "order": 2,
            "title": "Functional vs Non-Functional Requirements",
            "resource_type": "pdf",
            "resource_url": "https://drive.google.com/drive/folders/1553i9B1iO8HFAlHo1UhrIxiTYZdFfKtF",
            "content_extract": "",
            "duration_minutes": 55,
            "keywords": [
                "SRS",
                "functional",
                "non-functional",
                "reliability",
                "robustness",
                "usability",
                "scalability",
                "performance",
                "requirement engineering"
            ],
            "LLM_Summary": {
                "summary": "This lecture provides a comprehensive comparison between functional and non-functional requirements in software engineering. Functional requirements define the specific behaviors and functionalities of a system, such as data processing, user authentication, and API responses. Non-functional requirements, on the other hand, refer to the system's quality attributes, including performance, reliability, usability, and scalability. The lecture explains how these requirements shape software design and implementation while emphasizing the importance of clearly defining and documenting them in a Software Requirements Specification (SRS) document. The SRS structure typically includes an introduction, system overview, functional and non-functional requirements, external interface requirements, and system features. Functional requirements focus on the 'what' of a system, detailing use cases and system interactions, while non-functional requirements address the 'how' by setting quality benchmarks. Examples highlight how ambiguities in requirements can lead to costly revisions and failures. The lecture also discusses best practices for effective requirements gathering through stakeholder engagement, validation techniques, and traceability matrices to ensure consistency and alignment with business objectives.",
                "concepts_covered": [
                    "Definition and examples of functional requirements",
                    "Non-functional requirements and quality attributes",
                    "SRS document structure and best practices",
                    "Difference between functional and non-functional specifications",
                    "Requirement elicitation and validation techniques",
                    "Traceability and requirement mapping",
                    "Performance, scalability, and usability considerations",
                    "Impact of poorly defined requirements on project outcomes"
                ],
                "concepts_not_covered": [
                    "Agile user story mapping",
                    "Dynamic requirement changes in iterative models",
                    "Automated requirement traceability tools",
                    "Legal and compliance-related requirements"
                ]
            }
        }
        ,
        {
            "lecture_id": 5,
            "week_id": 3,
            "order": 1,
            "title": "Usability Principles in UI Design",
            "resource_type": "youtube",
            "video_url": "https://www.youtube.com/watch?v=BOCF3RefE54&t=1s",
            "content_transcript": "",
            "duration_minutes": 48,
            "keywords": ["usability", "ISO 9241", "effectiveness", "efficiency", "learnability", "safety", "memorability", "interaction design", "user experience"],
            "LLM_Summary": {
                "summary": "This lecture explores the core usability principles in UI design, guided by the ISO 9241 standard. It emphasizes five critical usability goals: effectiveness, efficiency, safety, learnability, and memorability. Real-world examples, including popular platforms like Google and Amazon, illustrate how these goals manifest in practice. The lecture also discusses interaction design, highlighting the iterative process of identifying user needs, developing alternative designs, and evaluating their usability. Special attention is given to ensuring user safety, both in critical environments (such as medical devices) and everyday applications, through error prevention and recovery mechanisms. Additionally, the lecture distinguishes usability goals from user experience goals, which focus on providing enjoyable and satisfying interactions. Techniques such as wizards, templates, and on-screen tooltips are introduced to enhance learnability and memorability, ensuring users can efficiently navigate both simple and complex systems. This comprehensive overview equips learners with the foundational knowledge required to design intuitive, user-centered interfaces.",
                "concepts_covered": [
                    "Usability dimensions (effectiveness, efficiency, safety, learnability, memorability)",
                    "Interaction design process and its relationship with agile methodologies",
                    "Error prevention and recovery strategies",
                    "Designing for user safety in both critical and non-critical applications",
                    "Consistency principles and their role in enhancing user experience",
                    "User experience goals versus usability goals",
                    "Techniques to improve learnability and memorability (e.g., wizards, templates, and tooltips)"
                ]
            }
        },
        {
            "lecture_id": 6,
            "week_id": 3,
            "order": 2,
            "title": "Prototyping Techniques for UI Design",
            "resource_type": "pdf",
            "resource_url": "https://drive.google.com/drive/folders/1jetSQfQ4p7GE7SPy0vX5vqvwKOfajv1q",
            "content_extract": "",
            "duration_minutes": 52,
            "keywords": ["prototyping", "storyboard", "paper prototype", "fidelity", "iteration", "user feedback", "UI/UX", "design evaluation"],
            "LLM_Summary": {
                "summary": "This lecture explores various prototyping techniques essential for user interface (UI) design, focusing on the trade-offs between fidelity levels, efficiency, and user-centered feedback. It covers the spectrum from low-fidelity to high-fidelity prototypes, detailing their benefits, use cases, and application in iterative design processes. Low-fidelity methods like storyboarding and paper prototypes emphasize rapid ideation and early-stage concept validation, while high-fidelity techniques like digital mockups and interactive prototypes support advanced usability testing and stakeholder communication. The lecture also discusses the relationship between fidelity and development time, balancing speed and detail to meet project goals. Emphasis is placed on the role of user testing throughout the prototyping lifecycle, ensuring designs evolve to meet real user needs.",
                "concepts_covered": [
                    "Prototyping techniques (low-fidelity to high-fidelity)",
                    "Storyboarding components and purpose",
                    "Paper prototypes for rapid validation",
                    "Digital mockups for detailed visualization",
                    "Interactive prototypes for advanced testing",
                    "Fidelity vs. time trade-offs in design",
                    "User testing methodologies and feedback loops",
                    "Iterative design and prototype refinement",
                    "Evaluating and selecting the right prototyping method"
                ]
            }
        }
        ,
        {
            "lecture_id": 7,
            "week_id": 4,
            "order": 1,
            "title": "Project Estimation Techniques",
            "resource_type": "youtube",
            "video_url": "https://www.youtube.com/watch?v=ziDmAaOrdkY",
            "content_transcript": "",
            "duration_minutes": 55,
            "keywords": ["estimation", "COCOMO", "KLOC", "person-month", "Delphi", "heuristic estimation", "empirical estimation"],
            "LLM_Summary": {
                "summary": "This lecture provides an in-depth understanding of software project estimation techniques, focusing on empirical and heuristic methods. It explains the importance of project estimation in determining cost, effort, and scheduling. The lecture covers key estimation parameters like lines of code (KLOC) and person-months for measuring development effort. Empirical estimation techniques include expert judgment and the Delphi method. While expert judgment relies on experienced individuals, it is prone to biases and errors. The Delphi technique mitigates these issues by using anonymous, iterative expert feedback. The lecture also explores heuristic estimation, particularly the COCOMO model, which uses mathematical expressions to estimate effort based on project size and complexity. The differences between organic, semi-detached, and embedded projects are discussed, with a worked example estimating the effort for an Amazon Seller Portal project. The lecture emphasizes how accurate estimates depend not only on code size but also on project type and team composition.",
                "concepts_covered": [
                    "Importance of project estimation",
                    "Key estimation parameters (KLOC, person-month)",
                    "Empirical estimation techniques (Expert Judgment, Delphi Method)",
                    "Heuristic estimation (COCOMO model)",
                    "Project classifications (organic, semi-detached, embedded)",
                    "Effort calculation using COCOMO",
                    "Impact of team composition and project complexity on estimation"
                ]
            }
        }
        ,
        {
            "lecture_id": 8,
            "week_id": 4,
            "order": 2,
            "title": "Agile Project Management with Scrum",
            "resource_type": "pdf",
            "resource_url": "https://drive.google.com/drive/folders/1ksF4-OlkEHZTUO4cacN-iKqUChiY-73T",
            "content_extract": "",
            "duration_minutes": 60,
            "keywords": ["scrum", "sprint", "backlog", "standup", "velocity", "retrospective", "iteration", "agile methodology"],
            "LLM_Summary": {
                "summary": "This lecture explores Agile Project Management with a focus on the Scrum framework, detailing its principles, roles, and iterative nature. It explains how Scrum enhances flexibility and customer collaboration through time-boxed sprints and frequent deliverables. The lecture elaborates on core Scrum ceremonies including Sprint Planning, Daily Standups, Sprint Reviews, and Retrospectives. It also covers backlog management, prioritization through user stories and story points, and the importance of continuous improvement. Key Scrum roles such as the Product Owner, Scrum Master, and Development Team are analyzed, along with their responsibilities in ensuring successful project delivery. Furthermore, it discusses velocity tracking for measuring team performance and the use of burndown charts for progress visualization. Emphasis is placed on adaptive planning, embracing change, and maintaining stakeholder involvement throughout the project lifecycle.",
                "concepts_covered": [
                    "Scrum framework principles",
                    "Roles in Scrum (Product Owner, Scrum Master, Development Team)",
                    "Sprint planning and backlog prioritization",
                    "Daily standups and iterative progress tracking",
                    "Sprint review and retrospective processes",
                    "User stories and story point estimation",
                    "Velocity measurement and burndown charts",
                    "Continuous delivery and iterative improvements",
                    "Stakeholder engagement and adaptive planning"
                ]
            }
        }        
    ],
  
    "questions": [
        {
        "question_id": 3001,
        "content": "Which of the following is NOT a phase in the traditional Waterfall model?",
        "type": "MCQ",
        "question_options": [
            "Requirements",
            "Design",
            "Implementation",
            "Retrospective"
        ],
        "correct_answer": 3,
        "points": 8,
        "explanation": "Retrospective is an Agile practice, not part of the traditional Waterfall model phases.",
        "course_id": 2,
        "week_id": 1,
        "lecture_id": 1,
        "status": "active",
        "tags": ["SDLC", "Waterfall"]
        },
        {
        "question_id": 3002,
        "content": "Which Agile practices emphasize continuous improvement? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Sprint Retrospective",
            "Daily Standup",
            "Backlog Grooming",
            "Pair Programming",
            "Burndown Charts"
        ],
        "correct_answer": [0, 1],
        "points": 10,
        "explanation": "Sprint Retrospectives and Daily Standups focus on continuous improvement through regular reflection and adjustment.",
        "course_id": 2,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": ["Agile", "continuous improvement"]
        },
        {
        "question_id": 3003,
        "content": "Calculate the velocity of a team that completed 12 story points in Sprint 1, 15 in Sprint 2, and 13 in Sprint 3.",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 13,
        "points": 8,
        "explanation": "Velocity is calculated as the average of completed story points: (12+15+13)/3 = 13.33 (rounded to 13).",
        "course_id": 2,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": ["Agile", "velocity"]
        },
        {
        "question_id": 3004,
        "content": "Which requirement gathering technique is most effective for understanding user workflows?",
        "type": "MCQ",
        "question_options": [
            "Questionnaires",
            "Naturalistic Observation",
            "Document Analysis",
            "Focus Groups"
        ],
        "correct_answer": 1,
        "points": 8,
        "explanation": "Naturalistic Observation allows direct observation of users in their actual work environment.",
        "course_id": 2,
        "week_id": 2,
        "lecture_id": 3,
        "status": "active",
        "tags": ["requirements", "gathering"]
        },
        {
        "question_id": 3005,
        "content": "What are characteristics of good user stories? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Independent",
            "Negotiable",
            "Valuable",
            "Estimable",
            "Small",
            "Testable"
        ],
        "correct_answer": [0, 1, 2, 3, 4, 5],
        "points": 12,
        "explanation": "Good user stories follow the INVEST criteria: Independent, Negotiable, Valuable, Estimable, Small, and Testable.",
        "course_id": 2,
        "week_id": 2,
        "lecture_id": 4,
        "status": "active",
        "tags": ["user stories", "Agile"]
        },
        {
        "question_id": 3006,
        "content": "How many actors would a typical ATM system use case diagram have?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 2,
        "points": 8,
        "explanation": "A basic ATM system typically has 2 actors: Customer and Bank (or Maintenance Personnel).",
        "course_id": 2,
        "week_id": 2,
        "lecture_id": 4,
        "status": "active",
        "tags": ["use cases", "UML"]
        },
        {
        "question_id": 3007,
        "content": "Which of the following is an example of a non-functional requirement?",
        "type": "MCQ",
        "question_options": [
            "User can search products by name",
            "System must support 1000 concurrent users",
            "Admin can view sales reports",
            "Customer can add items to cart"
        ],
        "correct_answer": 1,
        "points": 8,
        "explanation": "Supporting concurrent users is a non-functional requirement about system performance.",
        "course_id": 2,
        "week_id": 2,
        "lecture_id": 4,
        "status": "active",
        "tags": ["requirements", "non-functional"]
        },
        {
        "question_id": 3008,
        "content": "Which SDLC model would be most appropriate for a project with unclear requirements?",
        "type": "MCQ",
        "question_options": [
            "Waterfall",
            "Spiral",
            "Prototype",
            "V-Model"
        ],
        "correct_answer": 2,
        "points": 10,
        "explanation": "Prototype model is ideal when requirements are unclear as it allows for iterative refinement.",
        "course_id": 2,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": ["SDLC", "models"]
        },
        {
        "question_id": 3009,
        "content": "What percentage of Agile teams typically use Scrum according to recent surveys?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 58,
        "points": 8,
        "explanation": "Recent surveys show approximately 58% of Agile teams use Scrum as their primary methodology.",
        "course_id": 2,
        "week_id": 1,
        "lecture_id": 2,
        "status": "active",
        "tags": ["Agile", "Scrum"]
        },
        {
        "question_id": 3010,
        "content": "Which elements should be included in a use case description? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Preconditions",
            "Main Flow",
            "Alternative Flows",
            "Postconditions",
            "Exceptions"
        ],
        "correct_answer": [0, 1, 2, 3, 4],
        "points": 12,
        "explanation": "A complete use case description includes all these elements to fully capture the scenario.",
        "course_id": 2,
        "week_id": 2,
        "lecture_id": 4,
        "status": "active",
        "tags": ["use cases", "requirements"]
        },
        {
        "question_id": 3011,
        "content": "Which architectural pattern separates an application into Model, View, and Controller components?",
        "type": "MCQ",
        "question_options": [
            "MVC",
            "Layered",
            "Microservices",
            "Event-Driven"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "MVC (Model-View-Controller) is the pattern that separates these concerns.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 5,
        "status": "active",
        "tags": ["architecture", "design patterns"]
        },
        {
        "question_id": 3012,
        "content": "Which design pattern ensures only one instance of a class exists?",
        "type": "MCQ",
        "question_options": [
            "Singleton",
            "Factory",
            "Observer",
            "Decorator"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "The Singleton pattern restricts instantiation to a single object instance.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 5,
        "status": "active",
        "tags": ["design patterns"]
        },
        {
        "question_id": 3013,
        "content": "How many relationships are shown in a basic Class Diagram for a simple e-commerce system?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 4,
        "points": 15,
        "explanation": "A basic e-commerce Class Diagram typically shows 4 core relationships: Customer-Order, Order-Product, Product-Category, and Customer-Payment.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 6,
        "status": "active",
        "tags": ["UML", "class diagram"]
        },
        {
        "question_id": 3014,
        "content": "Which SOLID principle states that a class should have only one reason to change?",
        "type": "MCQ",
        "question_options": [
            "Single Responsibility",
            "Open-Closed",
            "Liskov Substitution",
            "Interface Segregation"
        ],
        "correct_answer": 0,
        "points": 15,
        "explanation": "Single Responsibility Principle (SRP) states that a class should have only one responsibility.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 6,
        "status": "active",
        "tags": ["SOLID", "OOP"]
        },
        {
        "question_id": 3015,
        "content": "Which testing levels verify interactions between integrated components? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Unit Testing",
            "Integration Testing",
            "System Testing",
            "Acceptance Testing"
        ],
        "correct_answer": [1],
        "points": 12,
        "explanation": "Integration Testing specifically focuses on verifying interactions between components.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 7,
        "status": "active",
        "tags": ["testing", "integration"]
        },
        {
        "question_id": 3016,
        "content": "What is the minimum number of test cases required for 100% branch coverage of a simple if-else statement?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 2,
        "points": 15,
        "explanation": "You need at least 2 test cases: one for the true branch and one for the false branch.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 7,
        "status": "active",
        "tags": ["testing", "coverage"]
        },
        {
        "question_id": 3017,
        "content": "Which quality attribute measures how easily a system can handle increased workload?",
        "type": "MCQ",
        "question_options": [
            "Reliability",
            "Scalability",
            "Maintainability",
            "Security"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Scalability refers to a system's ability to handle growth in workload.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 8,
        "status": "active",
        "tags": ["quality attributes"]
        },
        {
        "question_id": 3018,
        "content": "Which UML diagram best shows object interactions in a specific scenario?",
        "type": "MCQ",
        "question_options": [
            "Class Diagram",
            "Sequence Diagram",
            "Component Diagram",
            "Deployment Diagram"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Sequence Diagrams specifically show object interactions over time.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 6,
        "status": "active",
        "tags": ["UML", "diagrams"]
        },
        {
        "question_id": 3019,
        "content": "Which patterns are creational design patterns? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Singleton",
            "Adapter",
            "Factory Method",
            "Observer",
            "Builder"
        ],
        "correct_answer": [0, 2, 4],
        "points": 12,
        "explanation": "Singleton, Factory Method, and Builder are creational patterns. Adapter is structural, and Observer is behavioral.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 5,
        "status": "active",
        "tags": ["design patterns", "creational"]
        },
        {
        "question_id": 3020,
        "content": "How many test cases are needed for pairwise testing of 3 parameters with 2 values each?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 4,
        "points": 15,
        "explanation": "Pairwise testing for 3 binary parameters requires 4 test cases to cover all pairs.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 7,
        "status": "active",
        "tags": ["testing", "combinatorial"]
        },
        {
        "question_id": 3021,
        "content": "Which architectural style is most suitable for a highly scalable web application?",
        "type": "MCQ",
        "question_options": [
            "Monolithic",
            "Microservices",
            "Client-Server",
            "Peer-to-Peer"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Microservices architecture provides the best scalability for web applications.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 5,
        "status": "active",
        "tags": ["architecture", "scalability"]
        },
        {
        "question_id": 3022,
        "content": "Which principles contribute to maintainable code? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Low Coupling",
            "High Cohesion",
            "Code Duplication",
            "Magic Numbers",
            "Clear Naming"
        ],
        "correct_answer": [0, 1, 4],
        "points": 12,
        "explanation": "Low Coupling, High Cohesion, and Clear Naming all contribute to maintainable code.",
        "course_id": 2,
        "week_id": 3,
        "lecture_id": 6,
        "status": "active",
        "tags": ["maintainability", "OOP"]
        },
        {
        "question_id": 3023,
        "content": "What percentage of defects are typically found during unit testing according to industry studies?",
        "type": "NUMERIC",
        "question_options": [],
        "correct_answer": 25,
        "points": 15,
        "explanation": "Industry studies show about 25% of defects are caught during unit testing.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 7,
        "status": "active",
        "tags": ["testing", "defects"]
        },
        {
        "question_id": 3024,
        "content": "Which testing technique is most effective for finding security vulnerabilities?",
        "type": "MCQ",
        "question_options": [
            "Unit Testing",
            "Penetration Testing",
            "Regression Testing",
            "Usability Testing"
        ],
        "correct_answer": 1,
        "points": 15,
        "explanation": "Penetration Testing specifically targets security vulnerabilities.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 7,
        "status": "active",
        "tags": ["testing", "security"]
        },
        {
        "question_id": 3025,
        "content": "Which quality attributes are most important for a banking system? Select all that apply.",
        "type": "MSQ",
        "question_options": [
            "Security",
            "Performance",
            "Reliability",
            "Scalability",
            "Modifiability"
        ],
        "correct_answer": [0, 1, 2],
        "points": 12,
        "explanation": "Security, Performance, and Reliability are critical for banking systems.",
        "course_id": 2,
        "week_id": 4,
        "lecture_id": 8,
        "status": "active",
        "tags": ["quality attributes", "banking"]
        }
    ],
    "assignments": [
        {
        "assignment_id": 3001,
        "week_id": 1,
        "title": "SDLC and Agile Fundamentals",
        "description": "Practice questions on software development life cycles and Agile methodologies",
        "type": "practice",
        "due_date": "2025-05-10",
        "start_date": "2025-05-03",
        "is_published": true,
        "question_ids": [3001, 3002, 3003, 3008, 3009]
        },
        {
        "assignment_id": 3002,
        "week_id": 2,
        "title": "Requirements and User Stories",
        "description": "Practice identifying and documenting requirements and creating effective user stories",
        "type": "practice",
        "due_date": "2025-05-17",
        "start_date": "2025-05-10",
        "is_published": true,
        "question_ids": [3004, 3005, 3006, 3007, 3010]
        },
        {
        "assignment_id": 3003,
        "week_id": 2,
        "title": "Use Cases and Requirements Analysis",
        "description": "Practice creating use case diagrams and analyzing functional/non-functional requirements",
        "type": "practice",
        "due_date": "2025-05-24",
        "start_date": "2025-05-17",
        "is_published": true,
        "question_ids": [3006, 3007, 3010, 3004, 3005]
        },
        {
        "assignment_id": 3004,
        "week_id": 3,
        "title": "Software Architecture and Design",
        "description": "Graded assignment on architectural patterns, design patterns, and OOP principles",
        "type": "graded",
        "due_date": "2025-05-31",
        "start_date": "2025-05-24",
        "is_published": true,
        "question_ids": [3011, 3012, 3014, 3018, 3019, 3021, 3022]
        },
        {
        "assignment_id": 3005,
        "week_id": 4,
        "title": "Software Quality and Testing",
        "description": "Graded assignment on testing techniques and software quality attributes",
        "type": "graded",
        "due_date": "2025-06-07",
        "start_date": "2025-05-31",
        "is_published": true,
        "question_ids": [3015, 3016, 3017, 3020, 3023, 3024, 3025]
        }
    ],
  
    "personal_resources": [
        {
            "resource_id": 1,
            "name": "SE Process Notes",
            "description": "Extensive personal notes covering a range of software development models, their methodologies, strengths, limitations, and real-world applications.",
            "course_id": 2,
            "user_id": 2001,
            "is_active": true,
            "LLM_Summary": {
            "summary": "In-depth notes on software development processes, detailing the phases, characteristics, and comparative analysis of key SDLC models, including real-world applicability and practical implications.",
            "concepts_covered": [
                "Waterfall model phases and their sequential nature",
                "Prototype model benefits with iterative refinement and risk mitigation",
                "Spiral model characteristics combining iterative development with risk analysis",
                "Agile principles emphasizing flexibility, collaboration, and incremental delivery",
                "Testing methodologies: Unit, Integration, System, and User Acceptance Testing",
                "Requirement gathering and documentation best practices",
                "Maintenance phases: corrective, adaptive, perfective, and preventive maintenance"
            ],
            "concepts_not_covered": [
                "In-depth tool-specific implementation (e.g., JIRA, Git workflows)",
                "Industry-specific case studies and real-world project comparisons",
                "Scalability concerns in large-scale software development",
                "Advanced SDLC hybrid models (e.g., DevOps and Scrumban)"
            ]
            }
        }
        ],

        "personal_resource_files": [
        {
            "file_id": 1,
            "resource_id": 1,
            "name": "Week 1-2 Notes",
            "type": "text",
            "content": "# Software Engineering Notes\n\n## Development Models\n\n### 1. Waterfall Model\n- **Phases**: Requirements → Design → Implementation → Testing → Maintenance\n- **Key Features**: Sequential, phase-dependent approach\n- **Advantages**: Clear structure, well-suited for projects with well-defined requirements\n- **Limitations**: Inflexible to changes, late-stage error discovery\n\n### 2. Prototype Model\n- **Process**: Develop prototype → Gather feedback → Refine\n- **Key Features**: Emphasizes early user involvement and iterative feedback\n- **Advantages**: Reduced risk of requirement misunderstandings, rapid feedback loop\n- **Limitations**: Potential for scope creep, increased time if many iterations\n\n### 3. Spiral Model\n- **Phases**: Planning → Risk Analysis → Engineering → Evaluation (iterates)\n- **Key Features**: Risk-driven, integrates iterative and waterfall aspects\n- **Advantages**: Risk reduction, better for complex and evolving systems\n- **Limitations**: Expensive, complex management required\n\n### 4. Agile Model\n- **Principles**: Customer collaboration, incremental delivery, responsiveness to change\n- **Key Features**: Iterative development, continuous feedback, adaptive planning\n- **Advantages**: High flexibility, faster delivery of working software\n- **Limitations**: Less documentation, challenging for large teams",
            "file_type": "text/markdown",
            "file_size": 6144
        },
        {
            "file_id": 2,
            "resource_id": 1,
            "name": "Requirement Templates",
            "type": "file",
            "content": "A curated collection of templates for documenting various software requirements, including:\n\n1. Functional and Non-Functional Requirements\n2. User Stories with Acceptance Criteria\n3. Software Requirement Specification (SRS) Outline\n4. Traceability Matrix\n\nEach template is designed to ensure comprehensive coverage and facilitate effective communication between stakeholders and development teams.",
            "file_path": "/uploads/user2001/se101/req_templates.docx",
            "file_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "file_size": 8192
        },
        {
            "file_id": 3,
            "resource_id": 1,
            "name": "Testing Methodologies Overview",
            "type": "text",
            "content": "# Software Testing Methodologies\n\n## 1. Unit Testing\n- **Purpose**: Validate individual components or functions\n- **Tools**: pytest (Python), JUnit (Java)\n\n## 2. Integration Testing\n- **Purpose**: Ensure proper interaction between integrated components\n- **Approaches**: Top-down, bottom-up, sandwich\n\n## 3. System Testing\n- **Purpose**: Validate the complete and integrated system\n- **Types**: Functional, non-functional (performance, security)\n\n## 4. User Acceptance Testing (UAT)\n- **Purpose**: Verify system compliance with user requirements\n- **Outcome**: Approve software for deployment",
            "file_type": "text/markdown",
            "file_size": 5120
        }
    ]

  }